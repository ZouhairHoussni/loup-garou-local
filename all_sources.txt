ROOT: C:\Users\POEC-9\Desktop\my_projects\loup_garou_mvp
EXTENSIONS: .css, .html, .js, .py
EXCLUDED DIRS: .env, .git, .hg, .idea, .mypy_cache, .next, .nuxt, .pytest_cache, .ruff_cache, .svn, .venv, .vscode, __pycache__, build, dist, env, node_modules, venv

====================================================================================================
PATH: dump_ressources.py
------------------------
#!/usr/bin/env python3
"""
Dump selected source files into one .txt file.

- Recursively crawls a folder
- Includes only: .py, .css, .html, .js
- Writes: a header with the relative path, then the file content
- Tries UTF-8 first; falls back to latin-1; replaces undecodable chars
- Skips common noisy folders (venv, node_modules, .git, __pycache__, etc.)
"""

from __future__ import annotations
from pathlib import Path
import argparse

DEFAULT_EXTS = {".py", ".css", ".html", ".js"}
DEFAULT_EXCLUDE_DIRS = {
    ".git", ".hg", ".svn",
    "__pycache__", ".pytest_cache",
    ".mypy_cache", ".ruff_cache",
    "venv", ".venv", "env", ".env",
    "node_modules", "dist", "build", ".next", ".nuxt",
    ".idea", ".vscode",
}

SEPARATOR = "\n" + ("=" * 100) + "\n"


def should_skip_dir(dir_path: Path, exclude_names: set[str]) -> bool:
    return dir_path.name in exclude_names


def read_text_safely(p: Path) -> str:
    # Try UTF-8, then latin-1; finally replace errors with UTF-8.
    for enc in ("utf-8", "utf-8-sig", "latin-1"):
        try:
            return p.read_text(encoding=enc)
        except UnicodeDecodeError:
            continue
        except Exception as e:
            return f"<<ERROR reading file: {e}>>"
    try:
        return p.read_text(encoding="utf-8", errors="replace")
    except Exception as e:
        return f"<<ERROR reading file: {e}>>"


def crawl_and_dump(root: Path, out_file: Path, exts: set[str], exclude_dirs: set[str]) -> tuple[int, int]:
    root = root.resolve()
    out_file = out_file.resolve()

    # Collect files first (sorted for stable output)
    files: list[Path] = []

    for path in root.rglob("*"):
        if path.is_dir():
            if should_skip_dir(path, exclude_dirs):
                # Don't descend into excluded dirs: rglob doesn't support prune directly,
                # but we can skip collecting anything inside by ignoring later.
                continue

        if path.is_file() and path.suffix.lower() in exts:
            # Skip if any parent directory is excluded
            if any(parent.name in exclude_dirs for parent in path.parents):
                continue
            files.append(path)

    files.sort(key=lambda p: str(p).lower())

    total_files = 0
    total_bytes = 0

    with out_file.open("w", encoding="utf-8", newline="\n") as f:
        f.write(f"ROOT: {root}\n")
        f.write(f"EXTENSIONS: {', '.join(sorted(exts))}\n")
        f.write(f"EXCLUDED DIRS: {', '.join(sorted(exclude_dirs))}\n")
        f.write(SEPARATOR)

        for file_path in files:
            rel = file_path.relative_to(root)
            content = read_text_safely(file_path)

            header = f"PATH: {rel}\n"
            f.write(header)
            f.write("-" * (len(header) - 1) + "\n")
            f.write(content)
            if not content.endswith("\n"):
                f.write("\n")
            f.write(SEPARATOR)

            total_files += 1
            try:
                total_bytes += file_path.stat().st_size
            except OSError:
                pass

    return total_files, total_bytes


def main() -> None:
    parser = argparse.ArgumentParser(description="Crawl a folder and dump .py/.css/.html/.js into one txt file.")
    parser.add_argument("root", nargs="?", default=".", help="Root folder to crawl (default: current directory).")
    parser.add_argument("-o", "--out", default="dump.txt", help="Output txt file path (default: dump.txt).")
    parser.add_argument(
        "--exts",
        default=",".join(sorted(DEFAULT_EXTS)),
        help="Comma-separated extensions to include (default: .py,.css,.html,.js).",
    )
    parser.add_argument(
        "--exclude-dirs",
        default=",".join(sorted(DEFAULT_EXCLUDE_DIRS)),
        help="Comma-separated directory names to exclude (default includes venv,node_modules,.git,...).",
    )

    args = parser.parse_args()

    root = Path(args.root)
    out_file = Path(args.out)
    exts = {e.strip().lower() if e.strip().startswith(".") else "." + e.strip().lower()
            for e in args.exts.split(",") if e.strip()}
    exclude_dirs = {d.strip() for d in args.exclude_dirs.split(",") if d.strip()}

    if not root.exists() or not root.is_dir():
        raise SystemExit(f"Root folder does not exist or is not a directory: {root}")

    n_files, n_bytes = crawl_and_dump(root, out_file, exts, exclude_dirs)
    print(f"Done: wrote {n_files} files (~{n_bytes} bytes) to {out_file.resolve()}")


if __name__ == "__main__":
    main()

====================================================================================================
PATH: server.py
---------------
from __future__ import annotations

import asyncio
import json
import random
import time
import uuid
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional, Set

from fastapi import FastAPI, WebSocket
from fastapi.staticfiles import StaticFiles
from pathlib import Path
from fastapi.middleware.cors import CORSMiddleware


class Role(str, Enum):
    VILLAGER = "villager"
    WEREWOLF = "werewolf"
    SEER = "seer"
    WITCH = "witch"
    CUPID = "cupid"


ROLE_FR = {
    Role.VILLAGER: "Le Villageois",
    Role.WEREWOLF: "Le Loup-Garou",
    Role.SEER: "La Voyante",
    Role.WITCH: "La Sorcière",
    Role.CUPID: "Le Cupidon",
}

WINNER_FR = {
    "villagers": "Les Villageois",
    "werewolves": "Les Loups-Garous",
    "nobody": "Personne",
}

WEREWOLF_COUNT_RANGES = {
    (5, 7): 1,
    (8, 11): 2,
    (12, 15): 3,
    (16, 99): 4,
}

UNIQUE_ROLES = {Role.SEER, Role.WITCH, Role.CUPID}


def get_werewolf_count(player_count: int) -> int:
    for (min_p, max_p), wolf_count in WEREWOLF_COUNT_RANGES.items():
        if min_p <= player_count <= max_p:
            return wolf_count
    return 1


class Phase(str, Enum):
    LOBBY = "LOBBY"
    NIGHT = "NIGHT"
    DAY = "DAY"
    VOTE = "VOTE"
    RESULT = "RESULT"
    GAME_OVER = "GAME_OVER"


@dataclass
class Player:
    id: str
    name: str
    alive: bool = True
    role: Optional[Role] = None
    lover_id: Optional[str] = None
    witch_heal_used: bool = False
    witch_poison_used: bool = False


@dataclass
class Timers:
    phase_ends_at: Optional[float] = None
    seconds_left: Optional[int] = None


@dataclass
class ActionInbox:
    step: str = ""
    deadline: float = 0.0
    received: Dict[str, Any] = field(default_factory=dict)
    event: asyncio.Event = field(default_factory=asyncio.Event)


@dataclass
class VoteBox:
    deadline: float = 0.0
    votes: Dict[str, str] = field(default_factory=dict)
    event: asyncio.Event = field(default_factory=asyncio.Event)


@dataclass
class GameState:
    phase: Phase = Phase.LOBBY
    night_count: int = 0
    day_count: int = 0
    narrator: List[str] = field(default_factory=list)
    started: bool = False
    winner: Optional[str] = None
    wolves_victim: Optional[str] = None
    witch_heal: bool = False
    witch_poison_target: Optional[str] = None
    pending: ActionInbox = field(default_factory=ActionInbox)
    vote_box: VoteBox = field(default_factory=VoteBox)
    timers: Timers = field(default_factory=Timers)


class WSClientType(str, Enum):
    TV = "tv"
    PLAYER = "player"


@dataclass(eq=False)
class WSClient:
    websocket: WebSocket
    client_type: WSClientType
    player_id: Optional[str] = None


class Game:
    def __init__(self) -> None:
        self.state = GameState()
        self.players: Dict[str, Player] = {}
        self._lock = asyncio.Lock()
        self._clients: Set[WSClient] = set()
        self._runner_task: Optional[asyncio.Task] = None

        # Configurable timers
        self.T_DISCUSS = 15
        self.T_VOTE = 25
        self.T_NIGHT_STEP = 22
        self.T_RESULT = 5
        
        # Configurable roles
        self.use_seer = True
        self.use_witch = True
        self.use_cupid = True
        self.use_hunter = False

    def _alive_ids(self) -> List[str]:
        return [pid for pid, p in self.players.items() if p.alive]

    def _alive_players(self) -> List[Player]:
        return [p for p in self.players.values() if p.alive]

    def _players_by_role(self, role: Role) -> List[Player]:
        return [p for p in self.players.values() if p.alive and p.role == role]

    def _log(self, line: str) -> None:
        ts = time.strftime("%H:%M:%S")
        self.state.narrator.append(f"[{ts}] {line}")
        self.state.narrator = self.state.narrator[-200:]

    def _public_snapshot(self) -> Dict[str, Any]:
        alive = []
        dead = []
        for p in self.players.values():
            entry = {"id": p.id, "name": p.name, "alive": p.alive}
            if p.alive:
                alive.append(entry)
            else:
                entry["role"] = p.role.value if p.role else None
                entry["role_fr"] = ROLE_FR.get(p.role) if p.role else None
                dead.append(entry)

        return {
            "phase": self.state.phase,
            "night_count": self.state.night_count,
            "day_count": self.state.day_count,
            "started": self.state.started,
            "winner": self.state.winner,
            "alive": alive,
            "dead": dead,
            "timers": {
                "phase_ends_at": self.state.timers.phase_ends_at,
                "seconds_left": self.state.timers.seconds_left,
            },
        }

    def _private_snapshot(self, player_id: str) -> Dict[str, Any]:
        p = self.players.get(player_id)
        if not p:
            return {}
        base = self._public_snapshot()
        base["me"] = {
            "id": p.id,
            "name": p.name,
            "alive": p.alive,
            "role": p.role.value if p.role else None,
            "role_fr": ROLE_FR.get(p.role) if p.role else None,
            "lover_id": p.lover_id,
            "witch_heal_used": p.witch_heal_used,
            "witch_poison_used": p.witch_poison_used,
        }
        
        if self.state.phase == Phase.NIGHT and self.state.pending.step and time.time() <= self.state.pending.deadline:
            step = self.state.pending.step
            is_actor = ((step == "WOLVES" and p.role == Role.WEREWOLF)
                        or (step == "SEER" and p.role == Role.SEER)
                        or (step == "WITCH" and p.role == Role.WITCH)
                        or (step == "CUPID" and p.role == Role.CUPID))
            if is_actor and p.alive:
                base["pending_step"] = step
                base["pending_deadline"] = self.state.pending.deadline
            else:
                base["pending_step"] = None
                base["pending_deadline"] = None
        else:
            base["pending_step"] = None
            base["pending_deadline"] = None

        if p.role == Role.WEREWOLF:
            wolves_team = self._players_by_role(Role.WEREWOLF)
            base["wolves_team"] = [{"id": w.id, "name": w.name} for w in wolves_team]
            if self.state.pending.step == "WOLVES" and time.time() <= self.state.pending.deadline:
                votes: Dict[str, Optional[str]] = {}
                for w in wolves_team:
                    data = self.state.pending.received.get(w.id)
                    target = data.get("target") if isinstance(data, dict) else None
                    if target in self.players and self.players[target].alive and self.players[target].role != Role.WEREWOLF:
                        votes[w.id] = target
                    else:
                        votes[w.id] = None
                base["wolves_votes"] = votes

        if p.role == Role.WITCH and self.state.phase == Phase.NIGHT and self.state.wolves_victim:
            victim = self.state.wolves_victim
            base["witch_ctx"] = {
                "victim_id": victim,
                "victim_name": self.players[victim].name if victim in self.players else None,
            }

        if p.lover_id and p.lover_id in self.players:
            base["lover_name"] = self.players[p.lover_id].name
        return base

    async def _send(self, ws: WebSocket, msg: Dict[str, Any]) -> None:
        await ws.send_text(json.dumps(msg, ensure_ascii=False))

    async def _broadcast_public(self, msg: Dict[str, Any]) -> None:
        dead_clients = []
        for c in list(self._clients):
            try:
                await self._send(c.websocket, msg)
            except Exception:
                dead_clients.append(c)
        for c in dead_clients:
            self._clients.discard(c)

    async def _send_private(self, player_id: str, msg: Dict[str, Any]) -> None:
        dead_clients = []
        for c in list(self._clients):
            if c.client_type == WSClientType.PLAYER and c.player_id == player_id:
                try:
                    await self._send(c.websocket, msg)
                except Exception:
                    dead_clients.append(c)
        for c in dead_clients:
            self._clients.discard(c)

    async def _sync_all(self) -> None:
        await self._broadcast_public({"type": "PUBLIC_STATE", "data": self._public_snapshot()})
        for c in list(self._clients):
            if c.client_type == WSClientType.PLAYER and c.player_id:
                await self._send_private(c.player_id, {"type": "PRIVATE_STATE", "data": self._private_snapshot(c.player_id)})

    async def _narrate(self, line: str) -> None:
        self._log(line)
        await self._broadcast_public({"type": "NARRATOR_LINE", "line": self.state.narrator[-1]})

    async def join(self, name: str) -> str:
        async with self._lock:
            pid = uuid.uuid4().hex[:8]
            self.players[pid] = Player(id=pid, name=(name.strip()[:24] or f"Player-{pid}"))
        await self._narrate(f"{name} a rejoint le village.")
        await self._sync_all()
        return pid

    async def reset(self) -> None:
        async with self._lock:
            self.state = GameState()
            self.players = {}
            self._runner_task = None
        await self._broadcast_public({"type": "RESET"})

    async def configure(self, cfg: Dict[str, Any]) -> None:
        async with self._lock:
            if self.state.started:
                return
            if "nightAction" in cfg:
                self.T_NIGHT_STEP = max(10, min(120, int(cfg["nightAction"])))
            if "dayDiscuss" in cfg:
                self.T_DISCUSS = max(10, min(300, int(cfg["dayDiscuss"])))
            if "voteTime" in cfg:
                self.T_VOTE = max(10, min(120, int(cfg["voteTime"])))
            if "resultTime" in cfg:
                self.T_RESULT = max(3, min(30, int(cfg["resultTime"])))
            if "roles" in cfg:
                roles_cfg = cfg["roles"]
                self.use_seer = bool(roles_cfg.get("seer", True))
                self.use_witch = bool(roles_cfg.get("witch", True))
                self.use_cupid = bool(roles_cfg.get("cupid", True))
                self.use_hunter = bool(roles_cfg.get("hunter", False))

    async def start(self) -> None:
        async with self._lock:
            if self.state.started:
                return
            if len(self.players) < 5:
                raise ValueError("Il faut au moins 5 joueurs.")
            self.state.started = True
            self.state.phase = Phase.NIGHT
            self._assign_roles()

        await self._narrate("La partie commence. Les rôles ont été distribués.")
        await self._sync_all()

        if not self._runner_task or self._runner_task.done():
            self._runner_task = asyncio.create_task(self._run())

    def _assign_roles(self) -> None:
        ids = list(self.players.keys())
        random.shuffle(ids)
        
        player_count = len(ids)
        wolf_count = get_werewolf_count(player_count)
        
        roles: List[Role] = []
        for _ in range(wolf_count):
            roles.append(Role.WEREWOLF)
        
        # Add special roles based on config
        if self.use_seer:
            roles.append(Role.SEER)
        if self.use_witch:
            roles.append(Role.WITCH)
        if self.use_cupid:
            roles.append(Role.CUPID)
        
        villager_count = player_count - len(roles)
        roles += [Role.VILLAGER] * villager_count
        
        random.shuffle(roles)

        for pid, r in zip(ids, roles):
            self.players[pid].role = r

        for p in self.players.values():
            p.witch_heal_used = False
            p.witch_poison_used = False
            p.lover_id = None
            p.alive = True

    async def _run(self) -> None:
        while True:
            winner = self._check_winner()
            if winner:
                await self._end_game(winner)
                return

            await self._night()
            winner = self._check_winner()
            if winner:
                await self._end_game(winner)
                return

            await self._day_and_vote()
            winner = self._check_winner()
            if winner:
                await self._end_game(winner)
                return

    async def _night(self) -> None:
        async with self._lock:
            self.state.phase = Phase.NIGHT
            self.state.night_count += 1
            self.state.wolves_victim = None
            self.state.witch_heal = False
            self.state.witch_poison_target = None
        await self._narrate(f"Nuit {self.state.night_count}. Le village s'endort.")
        await self._sync_all()

        # Only run cupid on first night if enabled
        if self.state.night_count == 1 and self.use_cupid:
            await self._step_cupid()

        await self._step_wolves()
        
        # Only run seer if enabled
        if self.use_seer:
            await self._step_seer()
        
        # Only run witch if enabled
        if self.use_witch:
            await self._step_witch()
            
        await self._resolve_night()

    async def _day_and_vote(self) -> None:
        async with self._lock:
            self.state.phase = Phase.DAY
            self.state.day_count += 1
        await self._narrate(f"Jour {self.state.day_count}. Discutez.")
        await self._countdown(self.T_DISCUSS, phase=Phase.DAY, label="Discussion")
        await self._vote_phase()

    async def _vote_phase(self) -> None:
        async with self._lock:
            self.state.phase = Phase.VOTE
            self.state.vote_box = VoteBox()
            self.state.vote_box.deadline = time.time() + self.T_VOTE

        await self._narrate(f"Le vote commence ({self.T_VOTE}s).")
        await self._broadcast_public({"type": "VOTE_STARTED", "seconds": self.T_VOTE})
        await self._sync_all()

        while True:
            async with self._lock:
                alive = self._alive_ids()
                votes = dict(self.state.vote_box.votes)
                remaining = int(max(0, self.state.vote_box.deadline - time.time()))
                all_voted = len(votes) >= len(alive) and len(alive) > 0
                self.state.timers.phase_ends_at = self.state.vote_box.deadline
                self.state.timers.seconds_left = remaining

            await self._broadcast_public({"type": "VOTE_STATUS", "received": len(votes), "total": len(alive), "seconds_left": remaining})
            await self._sync_all()

            if all_voted or remaining <= 0:
                break
            await asyncio.sleep(1)

        await self._narrate("Vote terminé. Décompte...")
        await self._resolve_vote()

    async def _step_cupid(self) -> None:
        cupids = self._players_by_role(Role.CUPID)
        if not cupids:
            return
        cupid = cupids[0]
        await self._narrate("Cupidon, désigne deux amoureux.")
        await self._request_action(
            step="CUPID",
            actor_ids=[cupid.id],
            payload={"action": "cupid_pick_two"},
            timeout=self.T_NIGHT_STEP,
        )

        async with self._lock:
            data = self.state.pending.received.get(cupid.id) or {}
            if not isinstance(data, dict):
                data = {}
            lovers = data.get("targets") or []
            lovers = [x for x in lovers if x in self.players and self.players[x].alive]
            lovers = list(dict.fromkeys(lovers))
            if len(lovers) == 2:
                a, b = lovers
                self.players[a].lover_id = b
                self.players[b].lover_id = a
                asyncio.create_task(self._send_private(a, {"type": "LOVER_ASSIGNED", "lover_id": b, "lover_name": self.players[b].name}))
                asyncio.create_task(self._send_private(b, {"type": "LOVER_ASSIGNED", "lover_id": a, "lover_name": self.players[a].name}))

        await self._narrate("Cupidon ferme les yeux.")
        await self._sync_all()

    async def _step_wolves(self) -> None:
        wolves = self._players_by_role(Role.WEREWOLF)
        if not wolves:
            return
        await self._narrate("Les Loups-Garous, choisissez une victime.")

        actor_ids = [w.id for w in wolves if w.alive]
        if not actor_ids:
            return

        await self._request_wolves_vote(actor_ids=actor_ids, timeout=self.T_NIGHT_STEP)

        async with self._lock:
            alive_wolves = [wid for wid in actor_ids if wid in self.players and self.players[wid].alive]
            
            # Collect valid votes
            votes = []
            for wid in alive_wolves:
                data = self.state.pending.received.get(wid)
                t = data.get("target") if isinstance(data, dict) else None
                if t in self.players and self.players[t].alive and self.players[t].role != Role.WEREWOLF:
                    votes.append(t)

            victim = None
            if votes:
                # Majority vote (or random among tied leaders)
                tally = {}
                for t in votes:
                    tally[t] = tally.get(t, 0) + 1
                maxv = max(tally.values())
                leaders = [t for t, c in tally.items() if c == maxv]
                victim = random.choice(leaders)
            else:
                # NO VOTES: Pick random victim (wolves MUST kill)
                non_wolves = [p for p in self.players.values() if p.alive and p.role != Role.WEREWOLF]
                if non_wolves:
                    victim = random.choice(non_wolves).id
                    await self._narrate("Les loups n'ont pas choisi... la faim décide pour eux!")

            self.state.wolves_victim = victim

        await self._narrate("Les Loups-Garous ferment les yeux.")
        await self._sync_all()

    async def _step_seer(self) -> None:
        seers = self._players_by_role(Role.SEER)
        if not seers:
            return
        seer = seers[0]
        await self._narrate("La Voyante, choisis quelqu'un à révéler.")
        await self._request_action(
            step="SEER",
            actor_ids=[seer.id],
            payload={"action": "seer_pick_one"},
            timeout=self.T_NIGHT_STEP,
        )
        async with self._lock:
            data = self.state.pending.received.get(seer.id) or {}
            target = data.get("target") if isinstance(data, dict) else None
            if target in self.players and self.players[target].alive:
                role_obj = self.players[target].role
                role_key = role_obj.value if role_obj else None
                role_fr = ROLE_FR.get(role_obj) if role_obj else None
                await self._send_private(seer.id, {"type": "SEER_RESULT", "target_id": target, "target_name": self.players[target].name, "role": role_key, "role_fr": role_fr})
        await self._narrate("La Voyante ferme les yeux.")
        await self._sync_all()

    async def _step_witch(self) -> None:
        witches = self._players_by_role(Role.WITCH)
        if not witches:
            return
        witch = witches[0]
        async with self._lock:
            victim = self.state.wolves_victim

        # Send witch context BEFORE requesting action
        if victim and victim in self.players:
            await self._send_private(witch.id, {
                "type": "WITCH_CONTEXT",
                "wolves_victim_id": victim,
                "wolves_victim_name": self.players[victim].name,
                "heal_used": witch.witch_heal_used,
                "poison_used": witch.witch_poison_used,
            })

        await self._narrate("La Sorcière, utilise tes potions si tu le souhaites.")
        await self._request_action(
            step="WITCH",
            actor_ids=[witch.id],
            payload={"action": "witch_decide"},
            timeout=self.T_NIGHT_STEP,
        )
        async with self._lock:
            data = self.state.pending.received.get(witch.id) or {}
            if not isinstance(data, dict):
                data = {}
            heal = bool(data.get("heal"))
            poison_target = data.get("poison_target")
            if heal and not witch.witch_heal_used:
                witch.witch_heal_used = True
                self.state.witch_heal = True
            if poison_target in self.players and self.players[poison_target].alive and not witch.witch_poison_used:
                witch.witch_poison_used = True
                self.state.witch_poison_target = poison_target

        await self._narrate("La Sorcière ferme les yeux.")
        await self._sync_all()

    async def _resolve_night(self) -> None:
        async with self._lock:
            victim = self.state.wolves_victim
            deaths = set()

            if victim and not self.state.witch_heal:
                deaths.add(victim)

            if self.state.witch_poison_target:
                deaths.add(self.state.witch_poison_target)

            deaths_final = set()
            for d in deaths:
                if d in self.players and self.players[d].alive:
                    deaths_final.add(d)

            lover_deaths: Dict[str, str] = {}
            
            changed = True
            while changed:
                changed = False
                for d in list(deaths_final):
                    lover = self.players[d].lover_id if d in self.players else None
                    if lover and lover in self.players and self.players[lover].alive and lover not in deaths_final:
                        deaths_final.add(lover)
                        lover_deaths[lover] = d
                        changed = True

            for pid in deaths_final:
                self.players[pid].alive = False

        if not deaths_final:
            await self._narrate("L'aube se lève... personne n'est mort cette nuit!")
        else:
            primary_deaths = [pid for pid in deaths_final if pid not in lover_deaths]
            for pid in primary_deaths:
                p = self.players[pid]
                role_fr = ROLE_FR.get(p.role) if p.role else "-"
                await self._narrate(f"L'aube se lève... {p.name} est mort. ({role_fr})")
            
            for lover_pid, original_pid in lover_deaths.items():
                p = self.players[lover_pid]
                original_p = self.players[original_pid]
                role_fr = ROLE_FR.get(p.role) if p.role else "-"
                await self._narrate(f"{p.name} meurt de chagrin, amoureux de {original_p.name}. ({role_fr})")

        await self._sync_all()
        await asyncio.sleep(0.8)

    async def _resolve_vote(self) -> None:
        async with self._lock:
            alive = self._alive_ids()
            votes = dict(self.state.vote_box.votes)
            tally = {}
            for voter, target in votes.items():
                if voter in alive and target in alive:
                    tally[target] = tally.get(target, 0) + 1

            eliminated = None
            if tally:
                max_votes = max(tally.values())
                top = [pid for pid, c in tally.items() if c == max_votes]
                eliminated = random.choice(top)
            else:
                # No votes at all - random elimination
                if alive:
                    eliminated = random.choice(alive)

            if eliminated and eliminated in self.players:
                self.players[eliminated].alive = False

        safe_tally = [{"id": pid, "name": self.players[pid].name, "votes": cnt} for pid, cnt in sorted(tally.items(), key=lambda x: -x[1])]
        if eliminated:
            p = self.players[eliminated]
            await self._broadcast_public({
                "type": "VOTE_RESULT",
                "tally": safe_tally,
                "eliminated": {"id": eliminated, "name": p.name, "role": p.role.value if p.role else None, "role_fr": ROLE_FR.get(p.role) if p.role else None},
            })
            role_fr = ROLE_FR.get(p.role) if p.role else "-"
            await self._narrate(f"Le village a décidé: {p.name} est éliminé. ({role_fr})")
        else:
            await self._broadcast_public({"type": "VOTE_RESULT", "tally": safe_tally, "eliminated": None})
            await self._narrate("Personne n'a été éliminé.")

        await self._sync_all()
        await asyncio.sleep(self.T_RESULT)

    def _check_winner(self) -> Optional[str]:
        if not self.state.started:
            return None
        wolves = [p for p in self.players.values() if p.alive and p.role == Role.WEREWOLF]
        non_wolves = [p for p in self.players.values() if p.alive and p.role != Role.WEREWOLF]
        if len(self._alive_players()) == 0:
            return "nobody"
        if len(wolves) == 0:
            return "villagers"
        if len(wolves) >= len(non_wolves):
            return "werewolves"
        return None

    async def _end_game(self, winner: str) -> None:
        async with self._lock:
            self.state.phase = Phase.GAME_OVER
            self.state.winner = winner
        await self._narrate(f"Fin de partie! Victoire: {WINNER_FR.get(winner, winner)}.")
        await self._broadcast_public({"type": "GAME_OVER", "winner": winner, "winner_fr": WINNER_FR.get(winner, winner)})
        await self._sync_all()

    async def _request_action(self, step: str, actor_ids: List[str], payload: Dict[str, Any], timeout: int) -> None:
        async with self._lock:
            self.state.pending = ActionInbox(step=step, deadline=time.time() + timeout)
            self.state.pending.event.clear()

        for aid in actor_ids:
            if aid in self.players and self.players[aid].alive:
                await self._send_private(aid, {"type": "ACTION_REQUEST", "step": step, "deadline": self.state.pending.deadline, "payload": payload})

        while True:
            async with self._lock:
                received = dict(self.state.pending.received)
                remaining = int(max(0, self.state.pending.deadline - time.time()))
                alive_actors = [aid for aid in actor_ids if aid in self.players and self.players[aid].alive]
                done = all(aid in received for aid in alive_actors) or remaining <= 0
                self.state.timers.phase_ends_at = self.state.pending.deadline
                self.state.timers.seconds_left = remaining

            await self._sync_all()
            if done:
                break
            await asyncio.sleep(1)

    async def _request_wolves_vote(self, actor_ids: List[str], timeout: int) -> None:
        async with self._lock:
            self.state.pending = ActionInbox(step="WOLVES", deadline=time.time() + timeout)
            self.state.pending.event.clear()

        for aid in actor_ids:
            if aid in self.players and self.players[aid].alive:
                await self._send_private(aid, {
                    "type": "ACTION_REQUEST",
                    "step": "WOLVES",
                    "deadline": self.state.pending.deadline,
                    "payload": {"action": "wolf_vote_victim"},
                })

        announced_unanimity = False
        while True:
            async with self._lock:
                remaining = int(max(0, self.state.pending.deadline - time.time()))
                alive_actors = [aid for aid in actor_ids if aid in self.players and self.players[aid].alive]
                targets = []
                for wid in alive_actors:
                    data = self.state.pending.received.get(wid)
                    t = data.get("target") if isinstance(data, dict) else None
                    if t in self.players and self.players[t].alive and self.players[t].role != Role.WEREWOLF:
                        targets.append(t)

                unanimous = (len(alive_actors) > 0 and len(targets) == len(alive_actors) and len(set(targets)) == 1)
                self.state.timers.phase_ends_at = self.state.pending.deadline
                self.state.timers.seconds_left = remaining

            await self._sync_all()

            if unanimous and not announced_unanimity:
                announced_unanimity = True
                await self._narrate("Unanimité des loups atteinte.")

            if remaining <= 0 or unanimous:
                break
            await asyncio.sleep(1)

    async def submit_action(self, player_id: str, step: str, data: Dict[str, Any]) -> None:
        async with self._lock:
            if self.state.pending.step != step:
                return
            if time.time() > self.state.pending.deadline:
                return
            if player_id not in self.players or not self.players[player_id].alive:
                return
            self.state.pending.received[player_id] = data
            self.state.pending.event.set()

    async def cast_vote(self, voter_id: str, target_id: str) -> None:
        async with self._lock:
            if self.state.phase != Phase.VOTE:
                return
            if time.time() > self.state.vote_box.deadline:
                return
            if voter_id not in self.players or not self.players[voter_id].alive:
                return
            if target_id not in self.players or not self.players[target_id].alive:
                return
            self.state.vote_box.votes[voter_id] = target_id
            self.state.vote_box.event.set()

    async def _countdown(self, seconds: int, phase: Phase, label: str) -> None:
        end = time.time() + seconds
        while True:
            remaining = int(max(0, end - time.time()))
            async with self._lock:
                if self.state.phase != phase:
                    return
                self.state.timers.phase_ends_at = end
                self.state.timers.seconds_left = remaining
            await self._broadcast_public({"type": "COUNTDOWN", "label": label, "seconds_left": remaining})
            await self._sync_all()
            if remaining <= 0:
                break
            await asyncio.sleep(1)


app = FastAPI(title="Loup-Garou MVP")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

BASE_DIR = Path(__file__).resolve().parent
WEB_DIR = BASE_DIR / "web"
if WEB_DIR.exists():
    app.mount("/tv", StaticFiles(directory=str(WEB_DIR / "tv"), html=True), name="tv")
    app.mount("/player", StaticFiles(directory=str(WEB_DIR / "player"), html=True), name="player")
    app.mount("/static", StaticFiles(directory=str(WEB_DIR / "static")), name="static")

GAME = Game()


@app.get("/")
async def root():
    return {"ok": True, "hint": "Open /tv/ for TV, /player/ for players."}


@app.get("/api/health")
async def health():
    return {"ok": True, "phase": GAME.state.phase}


@app.post("/api/join")
async def api_join(payload: Dict[str, Any]):
    name = (payload.get("name") or "").strip() or "Player"
    pid = await GAME.join(name)
    return {"ok": True, "player_id": pid}


@app.post("/api/start")
async def api_start():
    try:
        await GAME.start()
        return {"ok": True}
    except ValueError as e:
        return {"ok": False, "error": str(e)}


@app.post("/api/reset")
async def api_reset():
    await GAME.reset()
    return {"ok": True}


@app.post("/api/config")
async def api_config(payload: Dict[str, Any]):
    await GAME.configure(payload)
    return {"ok": True}


@app.post("/api/action")
async def api_action(payload: Dict[str, Any]):
    player_id = payload.get("player_id")
    step = payload.get("step")
    data = payload.get("data") or {}
    if not isinstance(data, dict):
        data = {}
    if not player_id or not step:
        return {"ok": False, "error": "Missing player_id or step"}
    await GAME.submit_action(player_id, step, data)
    return {"ok": True}


@app.post("/api/vote")
async def api_vote(payload: Dict[str, Any]):
    voter_id = payload.get("voter_id")
    target_id = payload.get("target_id")
    if not voter_id or not target_id:
        return {"ok": False, "error": "Missing voter_id or target_id"}
    await GAME.cast_vote(voter_id, target_id)
    return {"ok": True}


@app.websocket("/ws")
async def websocket_endpoint(ws: WebSocket):
    await ws.accept()
    qp = dict(ws.query_params)
    client = qp.get("client", "tv")
    player_id = qp.get("player_id")

    if client not in ("tv", "player"):
        await ws.close()
        return

    ctype = WSClientType.TV if client == "tv" else WSClientType.PLAYER
    client_obj = WSClient(websocket=ws, client_type=ctype, player_id=player_id if ctype == WSClientType.PLAYER else None)
    GAME._clients.add(client_obj)

    await GAME._send(ws, {"type": "HELLO", "client": client, "player_id": player_id})
    await GAME._send(ws, {"type": "PUBLIC_STATE", "data": GAME._public_snapshot()})
    if ctype == WSClientType.PLAYER and player_id:
        await GAME._send(ws, {"type": "PRIVATE_STATE", "data": GAME._private_snapshot(player_id)})

    try:
        while True:
            msg = await ws.receive_text()
            try:
                data = json.loads(msg)
            except Exception:
                data = {"type": "PING"}
            if data.get("type") == "PING":
                await GAME._send(ws, {"type": "PONG"})
    except Exception:
        GAME._clients.discard(client_obj)
        try:
            await ws.close()
        except Exception:
            pass

====================================================================================================
PATH: tests\conftest.py
-----------------------
"""Shared fixtures and utilities for Loup-Garou tests."""
from __future__ import annotations

import asyncio
import sys
from pathlib import Path
from typing import Any, Dict, List

import pytest
from httpx import AsyncClient, ASGITransport

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from server import Game, Role, Phase, Player, app, GAME


@pytest.fixture
def game() -> Game:
    """Fresh Game instance for each test."""
    return Game()


@pytest.fixture
def event_loop():
    """Create an instance of the default event loop for each test case."""
    loop = asyncio.new_event_loop()
    yield loop
    loop.close()


async def add_players(game: Game, count: int, names: List[str] | None = None) -> List[str]:
    """Add players to a game and return their IDs."""
    if names is None:
        names = [f"Player{i+1}" for i in range(count)]
    
    player_ids = []
    for name in names[:count]:
        pid = await game.join(name)
        player_ids.append(pid)
    return player_ids


def count_roles(game: Game) -> Dict[Role, int]:
    """Count the number of each role assigned in the game."""
    counts: Dict[Role, int] = {}
    for player in game.players.values():
        if player.role:
            counts[player.role] = counts.get(player.role, 0) + 1
    return counts


def get_players_by_role(game: Game, role: Role) -> List[Player]:
    """Get all players with a specific role."""
    return [p for p in game.players.values() if p.role == role]


def get_alive_players(game: Game) -> List[Player]:
    """Get all alive players."""
    return [p for p in game.players.values() if p.alive]


def kill_player(game: Game, player_id: str) -> None:
    """Kill a player directly (for testing win conditions)."""
    if player_id in game.players:
        game.players[player_id].alive = False


def set_player_role(game: Game, player_id: str, role: Role) -> None:
    """Set a player's role directly (for testing specific scenarios)."""
    if player_id in game.players:
        game.players[player_id].role = role


@pytest.fixture
async def client():
    """Async HTTP client for API testing."""
    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as ac:
        yield ac


@pytest.fixture(autouse=True)
async def reset_global_game():
    """Reset the global GAME instance before each test."""
    await GAME.reset()
    yield
    await GAME.reset()

====================================================================================================
PATH: tests\test_api_endpoints.py
---------------------------------
"""Tests for REST API endpoints."""
from __future__ import annotations

import pytest
from httpx import AsyncClient


class TestHealthEndpoint:
    """Test health check endpoint."""

    @pytest.mark.asyncio
    async def test_health_returns_ok(self, client: AsyncClient):
        """Health endpoint should return ok status."""
        response = await client.get("/api/health")
        assert response.status_code == 200
        data = response.json()
        assert data["ok"] is True


class TestJoinEndpoint:
    """Test player join endpoint."""

    @pytest.mark.asyncio
    async def test_join_returns_player_id(self, client: AsyncClient):
        """Join should return a player ID."""
        response = await client.post("/api/join", json={"name": "TestPlayer"})
        assert response.status_code == 200
        data = response.json()
        assert data["ok"] is True
        assert "player_id" in data
        assert len(data["player_id"]) > 0

    @pytest.mark.asyncio
    async def test_join_with_empty_name(self, client: AsyncClient):
        """Join with empty name should still work (defaults to Player)."""
        response = await client.post("/api/join", json={"name": ""})
        assert response.status_code == 200
        data = response.json()
        assert data["ok"] is True

    @pytest.mark.asyncio
    async def test_join_truncates_long_name(self, client: AsyncClient):
        """Join should truncate names longer than 24 characters."""
        long_name = "A" * 50
        response = await client.post("/api/join", json={"name": long_name})
        assert response.status_code == 200
        data = response.json()
        assert data["ok"] is True


class TestStartEndpoint:
    """Test game start endpoint."""

    @pytest.mark.asyncio
    async def test_start_fails_without_enough_players(self, client: AsyncClient):
        """Start should fail with fewer than 5 players."""
        # Add only 3 players
        for i in range(3):
            await client.post("/api/join", json={"name": f"Player{i}"})
        
        response = await client.post("/api/start")
        data = response.json()
        assert data["ok"] is False
        assert "5 players" in data.get("error", "")

    @pytest.mark.asyncio
    async def test_start_succeeds_with_5_players(self, client: AsyncClient):
        """Start should succeed with 5 players."""
        for i in range(5):
            await client.post("/api/join", json={"name": f"Player{i}"})
        
        response = await client.post("/api/start")
        data = response.json()
        assert data["ok"] is True


class TestResetEndpoint:
    """Test game reset endpoint."""

    @pytest.mark.asyncio
    async def test_reset_returns_ok(self, client: AsyncClient):
        """Reset should return ok status."""
        response = await client.post("/api/reset")
        assert response.status_code == 200
        data = response.json()
        assert data["ok"] is True

    @pytest.mark.asyncio
    async def test_reset_clears_players(self, client: AsyncClient):
        """Reset should clear all players."""
        # Add some players
        for i in range(3):
            await client.post("/api/join", json={"name": f"Player{i}"})
        
        # Reset
        await client.post("/api/reset")
        
        # Health check should show LOBBY phase
        response = await client.get("/api/health")
        data = response.json()
        assert data["phase"] == "LOBBY"


class TestVoteEndpoint:
    """Test vote endpoint."""

    @pytest.mark.asyncio
    async def test_vote_requires_ids(self, client: AsyncClient):
        """Vote should require voter_id and target_id."""
        response = await client.post("/api/vote", json={})
        data = response.json()
        assert data["ok"] is False

    @pytest.mark.asyncio
    async def test_vote_with_missing_voter(self, client: AsyncClient):
        """Vote should fail without voter_id."""
        response = await client.post("/api/vote", json={"target_id": "abc"})
        data = response.json()
        assert data["ok"] is False


class TestActionEndpoint:
    """Test action endpoint."""

    @pytest.mark.asyncio
    async def test_action_requires_player_id(self, client: AsyncClient):
        """Action should require player_id."""
        response = await client.post("/api/action", json={"step": "WOLVES"})
        data = response.json()
        assert data["ok"] is False

    @pytest.mark.asyncio
    async def test_action_requires_step(self, client: AsyncClient):
        """Action should require step."""
        response = await client.post("/api/action", json={"player_id": "abc"})
        data = response.json()
        assert data["ok"] is False


class TestRootEndpoint:
    """Test root endpoint."""

    @pytest.mark.asyncio
    async def test_root_returns_hint(self, client: AsyncClient):
        """Root should return a helpful hint."""
        response = await client.get("/")
        assert response.status_code == 200
        data = response.json()
        assert data["ok"] is True
        assert "hint" in data

====================================================================================================
PATH: tests\test_game_phases.py
-------------------------------
"""Tests for game phase transitions."""
from __future__ import annotations

import pytest
from server import Game, Phase
from conftest import add_players


class TestPhaseTransitions:
    """Test game phase transitions."""

    @pytest.mark.asyncio
    async def test_initial_phase_is_lobby(self):
        """Game should start in LOBBY phase."""
        game = Game()
        assert game.state.phase == Phase.LOBBY

    @pytest.mark.asyncio
    async def test_start_transitions_to_night(self):
        """Starting the game should transition to NIGHT phase."""
        game = Game()
        await add_players(game, 5)
        await game.start()
        
        assert game.state.phase == Phase.NIGHT

    @pytest.mark.asyncio
    async def test_game_started_flag(self):
        """Game started flag should be True after start."""
        game = Game()
        await add_players(game, 5)
        await game.start()
        
        assert game.state.started is True

    @pytest.mark.asyncio
    async def test_night_count_increments(self):
        """Night count should start at 0 and increment."""
        game = Game()
        await add_players(game, 5)
        
        assert game.state.night_count == 0
        # Note: actual night phase runs async, we just check initial state


class TestPhaseInitialState:
    """Test initial state values."""

    @pytest.mark.asyncio
    async def test_initial_day_count(self):
        """Day count should start at 0."""
        game = Game()
        assert game.state.day_count == 0

    @pytest.mark.asyncio
    async def test_initial_night_count(self):
        """Night count should start at 0."""
        game = Game()
        assert game.state.night_count == 0

    @pytest.mark.asyncio
    async def test_initial_winner_is_none(self):
        """Winner should be None initially."""
        game = Game()
        assert game.state.winner is None

    @pytest.mark.asyncio
    async def test_initial_narrator_empty(self):
        """Narrator log should be empty initially."""
        game = Game()
        assert game.state.narrator == []


class TestGameOver:
    """Test GAME_OVER phase."""

    @pytest.mark.asyncio
    async def test_game_over_sets_winner(self):
        """Game over should set the winner."""
        game = Game()
        await add_players(game, 5)
        await game.start()
        
        await game._end_game("villagers")
        
        assert game.state.phase == Phase.GAME_OVER
        assert game.state.winner == "villagers"


class TestReset:
    """Test game reset functionality."""

    @pytest.mark.asyncio
    async def test_reset_clears_players(self):
        """Reset should clear all players."""
        game = Game()
        await add_players(game, 5)
        await game.reset()
        
        assert len(game.players) == 0

    @pytest.mark.asyncio
    async def test_reset_returns_to_lobby(self):
        """Reset should return to LOBBY phase."""
        game = Game()
        await add_players(game, 5)
        await game.start()
        await game.reset()
        
        assert game.state.phase == Phase.LOBBY

    @pytest.mark.asyncio
    async def test_reset_clears_started_flag(self):
        """Reset should clear the started flag."""
        game = Game()
        await add_players(game, 5)
        await game.start()
        await game.reset()
        
        assert game.state.started is False

    @pytest.mark.asyncio
    async def test_reset_clears_winner(self):
        """Reset should clear the winner."""
        game = Game()
        await add_players(game, 5)
        await game.start()
        await game._end_game("villagers")
        await game.reset()
        
        assert game.state.winner is None

====================================================================================================
PATH: tests\test_lover_mechanics.py
-----------------------------------
"""Tests for Cupid lover mechanics."""
from __future__ import annotations

import pytest
from server import Game, Role, Phase
from conftest import add_players, get_players_by_role, kill_player


class TestLoverAssignment:
    """Test lover assignment by Cupid."""

    @pytest.mark.asyncio
    async def test_lovers_linked_bidirectionally(self):
        """Lovers should be linked to each other."""
        game = Game()
        player_ids = await add_players(game, 5)
        await game.start()
        
        p1, p2 = player_ids[0], player_ids[1]
        
        # Simulate Cupid assigning lovers
        game.players[p1].lover_id = p2
        game.players[p2].lover_id = p1
        
        assert game.players[p1].lover_id == p2
        assert game.players[p2].lover_id == p1

    @pytest.mark.asyncio
    async def test_non_lovers_have_no_lover_id(self):
        """Non-lovers should have lover_id as None."""
        game = Game()
        player_ids = await add_players(game, 5)
        await game.start()
        
        # No lovers assigned yet
        for pid in player_ids:
            assert game.players[pid].lover_id is None


class TestLoverDeath:
    """Test lover death cascade."""

    @pytest.mark.asyncio
    async def test_lover_death_setup(self):
        """Test that lover relationship can be established."""
        game = Game()
        player_ids = await add_players(game, 5)
        await game.start()
        
        p1, p2 = player_ids[0], player_ids[1]
        
        # Assign lovers
        game.players[p1].lover_id = p2
        game.players[p2].lover_id = p1
        
        # Both should be alive initially
        assert game.players[p1].alive is True
        assert game.players[p2].alive is True

    @pytest.mark.asyncio
    async def test_lovers_can_be_killed(self):
        """Lovers can be killed just like other players."""
        game = Game()
        player_ids = await add_players(game, 5)
        await game.start()
        
        p1, p2 = player_ids[0], player_ids[1]
        
        # Assign lovers
        game.players[p1].lover_id = p2
        game.players[p2].lover_id = p1
        
        # Kill one lover
        kill_player(game, p1)
        
        assert game.players[p1].alive is False


class TestLoverRoleCombinations:
    """Test that lovers can be any role combination."""

    @pytest.mark.asyncio
    async def test_wolf_and_villager_lovers(self):
        """A werewolf and villager can be lovers."""
        game = Game()
        player_ids = await add_players(game, 5)
        await game.start()
        
        wolves = get_players_by_role(game, Role.WEREWOLF)
        villagers = get_players_by_role(game, Role.VILLAGER)
        
        if wolves and villagers:
            wolf = wolves[0]
            villager = villagers[0]
            
            # Assign as lovers
            game.players[wolf.id].lover_id = villager.id
            game.players[villager.id].lover_id = wolf.id
            
            assert game.players[wolf.id].lover_id == villager.id
            assert game.players[villager.id].lover_id == wolf.id

    @pytest.mark.asyncio
    async def test_two_villagers_lovers(self):
        """Two villagers can be lovers."""
        game = Game()
        player_ids = await add_players(game, 7)  # More players for more villagers
        await game.start()
        
        villagers = get_players_by_role(game, Role.VILLAGER)
        
        if len(villagers) >= 2:
            v1, v2 = villagers[0], villagers[1]
            
            game.players[v1.id].lover_id = v2.id
            game.players[v2.id].lover_id = v1.id
            
            assert game.players[v1.id].lover_id == v2.id
            assert game.players[v2.id].lover_id == v1.id


class TestLoverPrivacy:
    """Test that lover information is private."""

    @pytest.mark.asyncio
    async def test_public_snapshot_hides_lover(self):
        """Public snapshot should not reveal lover information."""
        game = Game()
        player_ids = await add_players(game, 5)
        await game.start()
        
        p1, p2 = player_ids[0], player_ids[1]
        game.players[p1].lover_id = p2
        game.players[p2].lover_id = p1
        
        snapshot = game._public_snapshot()
        
        # Public snapshot shouldn't have lover_id in alive list
        for player in snapshot["alive"]:
            assert "lover_id" not in player

    @pytest.mark.asyncio
    async def test_private_snapshot_shows_lover(self):
        """Private snapshot should reveal lover to the player."""
        game = Game()
        player_ids = await add_players(game, 5)
        await game.start()
        
        p1, p2 = player_ids[0], player_ids[1]
        game.players[p1].lover_id = p2
        game.players[p2].lover_id = p1
        
        snapshot = game._private_snapshot(p1)
        
        # Private snapshot should show lover_id
        assert snapshot["me"]["lover_id"] == p2

====================================================================================================
PATH: tests\test_night_actions.py
---------------------------------
"""Tests for night phase actions."""
from __future__ import annotations

import pytest
from server import Game, Role, Phase
from conftest import add_players, get_players_by_role, kill_player


class TestWerewolfVoting:
    """Test werewolf victim selection."""

    @pytest.mark.asyncio
    async def test_wolves_can_select_victim(self):
        """Werewolves should be able to propose a victim."""
        game = Game()
        await add_players(game, 5)
        await game.start()
        
        wolves = get_players_by_role(game, Role.WEREWOLF)
        non_wolves = [p for p in game.players.values() if p.role != Role.WEREWOLF]
        
        assert len(wolves) >= 1
        assert len(non_wolves) >= 1

    @pytest.mark.asyncio
    async def test_wolves_cannot_target_wolves(self):
        """Werewolves should not be able to target other werewolves."""
        game = Game()
        await add_players(game, 8)  # 2 werewolves
        await game.start()
        
        wolves = get_players_by_role(game, Role.WEREWOLF)
        assert len(wolves) == 2
        
        # Both wolves should be alive and identifiable
        for wolf in wolves:
            assert wolf.role == Role.WEREWOLF
            assert wolf.alive is True


class TestSeerAction:
    """Test Seer reveal action."""

    @pytest.mark.asyncio
    async def test_seer_exists_in_game(self):
        """Game should have a Seer after start."""
        game = Game()
        await add_players(game, 5)
        await game.start()
        
        seers = get_players_by_role(game, Role.SEER)
        assert len(seers) == 1

    @pytest.mark.asyncio
    async def test_seer_can_reveal_role(self):
        """Seer should be able to know another player's role."""
        game = Game()
        await add_players(game, 5)
        await game.start()
        
        seers = get_players_by_role(game, Role.SEER)
        seer = seers[0]
        
        # Pick a target (not the seer)
        targets = [p for p in game.players.values() if p.id != seer.id]
        target = targets[0]
        
        # The seer should be able to see the target's role
        assert target.role is not None


class TestWitchAction:
    """Test Witch heal and poison actions."""

    @pytest.mark.asyncio
    async def test_witch_exists_in_game(self):
        """Game should have a Witch after start."""
        game = Game()
        await add_players(game, 5)
        await game.start()
        
        witches = get_players_by_role(game, Role.WITCH)
        assert len(witches) == 1

    @pytest.mark.asyncio
    async def test_witch_starts_with_both_potions(self):
        """Witch should start with heal and poison unused."""
        game = Game()
        await add_players(game, 5)
        await game.start()
        
        witches = get_players_by_role(game, Role.WITCH)
        witch = witches[0]
        
        assert witch.witch_heal_used is False
        assert witch.witch_poison_used is False

    @pytest.mark.asyncio
    async def test_witch_heal_marks_as_used(self):
        """Using heal potion should mark it as used."""
        game = Game()
        await add_players(game, 5)
        await game.start()
        
        witches = get_players_by_role(game, Role.WITCH)
        witch = witches[0]
        
        # Simulate using heal
        witch.witch_heal_used = True
        
        assert witch.witch_heal_used is True

    @pytest.mark.asyncio
    async def test_witch_poison_marks_as_used(self):
        """Using poison potion should mark it as used."""
        game = Game()
        await add_players(game, 5)
        await game.start()
        
        witches = get_players_by_role(game, Role.WITCH)
        witch = witches[0]
        
        # Simulate using poison
        witch.witch_poison_used = True
        
        assert witch.witch_poison_used is True


class TestCupidAction:
    """Test Cupid lover assignment."""

    @pytest.mark.asyncio
    async def test_cupid_exists_in_game(self):
        """Game should have a Cupid after start."""
        game = Game()
        await add_players(game, 5)
        await game.start()
        
        cupids = get_players_by_role(game, Role.CUPID)
        assert len(cupids) == 1

    @pytest.mark.asyncio
    async def test_cupid_can_assign_lovers(self):
        """Cupid should be able to assign two lovers."""
        game = Game()
        player_ids = await add_players(game, 5)
        await game.start()
        
        # Simulate lover assignment
        p1, p2 = list(game.players.keys())[:2]
        game.players[p1].lover_id = p2
        game.players[p2].lover_id = p1
        
        assert game.players[p1].lover_id == p2
        assert game.players[p2].lover_id == p1

    @pytest.mark.asyncio
    async def test_lovers_start_without_assignment(self):
        """Players should start without lover assignment."""
        game = Game()
        await add_players(game, 5)
        await game.start()
        
        for player in game.players.values():
            assert player.lover_id is None


class TestNightResolution:
    """Test night death resolution."""

    @pytest.mark.asyncio
    async def test_wolf_victim_dies_without_heal(self):
        """Wolf victim should die if witch doesn't heal."""
        game = Game()
        await add_players(game, 5)
        await game.start()
        
        non_wolves = [p for p in game.players.values() if p.role != Role.WEREWOLF]
        victim = non_wolves[0]
        
        # Simulate wolf attack
        game.state.wolves_victim = victim.id
        game.state.witch_heal = False
        
        # The victim should be marked for death
        assert game.state.wolves_victim == victim.id
        assert game.state.witch_heal is False

    @pytest.mark.asyncio
    async def test_witch_heal_saves_victim(self):
        """Witch heal should save the wolf victim."""
        game = Game()
        await add_players(game, 5)
        await game.start()
        
        non_wolves = [p for p in game.players.values() if p.role != Role.WEREWOLF]
        victim = non_wolves[0]
        
        # Simulate wolf attack and witch heal
        game.state.wolves_victim = victim.id
        game.state.witch_heal = True
        
        assert game.state.witch_heal is True

    @pytest.mark.asyncio
    async def test_witch_poison_kills_target(self):
        """Witch poison should mark target for death."""
        game = Game()
        await add_players(game, 5)
        await game.start()
        
        wolves = get_players_by_role(game, Role.WEREWOLF)
        wolf = wolves[0]
        
        # Simulate witch poisoning a wolf
        game.state.witch_poison_target = wolf.id
        
        assert game.state.witch_poison_target == wolf.id

====================================================================================================
PATH: tests\test_role_assignment.py
-----------------------------------
"""Tests for role assignment rules following official Loup-Garou proportions."""
from __future__ import annotations

import pytest
from server import Game, Role, get_werewolf_count, UNIQUE_ROLES
from conftest import add_players, count_roles, get_players_by_role


class TestWerewolfCount:
    """Test werewolf count based on player count."""

    @pytest.mark.asyncio
    async def test_5_players_1_werewolf(self):
        """5 players should have exactly 1 werewolf."""
        game = Game()
        await add_players(game, 5)
        await game.start()
        
        roles = count_roles(game)
        assert roles.get(Role.WEREWOLF, 0) == 1

    @pytest.mark.asyncio
    async def test_7_players_1_werewolf(self):
        """7 players should have exactly 1 werewolf."""
        game = Game()
        await add_players(game, 7)
        await game.start()
        
        roles = count_roles(game)
        assert roles.get(Role.WEREWOLF, 0) == 1

    @pytest.mark.asyncio
    async def test_8_players_2_werewolves(self):
        """8 players should have exactly 2 werewolves."""
        game = Game()
        await add_players(game, 8)
        await game.start()
        
        roles = count_roles(game)
        assert roles.get(Role.WEREWOLF, 0) == 2

    @pytest.mark.asyncio
    async def test_11_players_2_werewolves(self):
        """11 players should have exactly 2 werewolves."""
        game = Game()
        await add_players(game, 11)
        await game.start()
        
        roles = count_roles(game)
        assert roles.get(Role.WEREWOLF, 0) == 2

    @pytest.mark.asyncio
    async def test_12_players_3_werewolves(self):
        """12 players should have exactly 3 werewolves."""
        game = Game()
        await add_players(game, 12)
        await game.start()
        
        roles = count_roles(game)
        assert roles.get(Role.WEREWOLF, 0) == 3

    @pytest.mark.asyncio
    async def test_15_players_3_werewolves(self):
        """15 players should have exactly 3 werewolves."""
        game = Game()
        await add_players(game, 15)
        await game.start()
        
        roles = count_roles(game)
        assert roles.get(Role.WEREWOLF, 0) == 3

    @pytest.mark.asyncio
    async def test_16_players_4_werewolves(self):
        """16 players should have exactly 4 werewolves."""
        game = Game()
        await add_players(game, 16)
        await game.start()
        
        roles = count_roles(game)
        assert roles.get(Role.WEREWOLF, 0) == 4


class TestUniqueRoles:
    """Test that special roles appear at most once."""

    @pytest.mark.asyncio
    async def test_only_one_seer(self):
        """There should be at most 1 Seer."""
        game = Game()
        await add_players(game, 10)
        await game.start()
        
        roles = count_roles(game)
        assert roles.get(Role.SEER, 0) <= 1

    @pytest.mark.asyncio
    async def test_only_one_witch(self):
        """There should be at most 1 Witch."""
        game = Game()
        await add_players(game, 10)
        await game.start()
        
        roles = count_roles(game)
        assert roles.get(Role.WITCH, 0) <= 1

    @pytest.mark.asyncio
    async def test_only_one_cupid(self):
        """There should be at most 1 Cupid."""
        game = Game()
        await add_players(game, 10)
        await game.start()
        
        roles = count_roles(game)
        assert roles.get(Role.CUPID, 0) <= 1

    @pytest.mark.asyncio
    async def test_unique_roles_with_many_players(self):
        """Even with 20 players, unique roles should only appear once."""
        game = Game()
        await add_players(game, 20)
        await game.start()
        
        roles = count_roles(game)
        for role in UNIQUE_ROLES:
            assert roles.get(role, 0) <= 1, f"{role} should appear at most once"


class TestAllPlayersGetRoles:
    """Test that all players receive a role."""

    @pytest.mark.asyncio
    async def test_all_players_have_roles(self):
        """All players should receive a role after game starts."""
        game = Game()
        await add_players(game, 8)
        await game.start()
        
        for player in game.players.values():
            assert player.role is not None, f"Player {player.name} has no role"

    @pytest.mark.asyncio
    async def test_remaining_players_are_villagers(self):
        """Players not assigned special roles should be Villagers."""
        game = Game()
        await add_players(game, 10)
        await game.start()
        
        roles = count_roles(game)
        total_special = (
            roles.get(Role.WEREWOLF, 0) +
            roles.get(Role.SEER, 0) +
            roles.get(Role.WITCH, 0) +
            roles.get(Role.CUPID, 0)
        )
        expected_villagers = 10 - total_special
        assert roles.get(Role.VILLAGER, 0) == expected_villagers


class TestGetWerewolfCount:
    """Test the get_werewolf_count helper function."""

    def test_5_players(self):
        assert get_werewolf_count(5) == 1

    def test_7_players(self):
        assert get_werewolf_count(7) == 1

    def test_8_players(self):
        assert get_werewolf_count(8) == 2

    def test_11_players(self):
        assert get_werewolf_count(11) == 2

    def test_12_players(self):
        assert get_werewolf_count(12) == 3

    def test_15_players(self):
        assert get_werewolf_count(15) == 3

    def test_16_players(self):
        assert get_werewolf_count(16) == 4

    def test_20_players(self):
        assert get_werewolf_count(20) == 4


class TestMinimumPlayers:
    """Test minimum player requirements."""

    @pytest.mark.asyncio
    async def test_cannot_start_with_4_players(self):
        """Game should not start with fewer than 5 players."""
        game = Game()
        await add_players(game, 4)
        
        with pytest.raises(ValueError, match="at least 5 players"):
            await game.start()

    @pytest.mark.asyncio
    async def test_can_start_with_5_players(self):
        """Game should start with exactly 5 players."""
        game = Game()
        await add_players(game, 5)
        await game.start()
        
        assert game.state.started is True

====================================================================================================
PATH: tests\test_vote_phase.py
------------------------------
"""Tests for day voting phase."""
from __future__ import annotations

import pytest
from server import Game, Role, Phase
from conftest import add_players, get_players_by_role, kill_player


class TestVoteCasting:
    """Test vote casting mechanics."""

    @pytest.mark.asyncio
    async def test_player_can_cast_vote(self):
        """Alive player should be able to cast a vote."""
        game = Game()
        player_ids = await add_players(game, 5)
        await game.start()
        
        # Set up vote phase
        game.state.phase = Phase.VOTE
        game.state.vote_box.deadline = float('inf')  # No timeout for test
        
        voter = player_ids[0]
        target = player_ids[1]
        
        await game.cast_vote(voter, target)
        
        assert game.state.vote_box.votes.get(voter) == target

    @pytest.mark.asyncio
    async def test_dead_player_cannot_vote(self):
        """Dead player should not be able to cast a vote."""
        game = Game()
        player_ids = await add_players(game, 5)
        await game.start()
        
        game.state.phase = Phase.VOTE
        game.state.vote_box.deadline = float('inf')
        
        voter = player_ids[0]
        target = player_ids[1]
        
        # Kill the voter
        kill_player(game, voter)
        
        await game.cast_vote(voter, target)
        
        # Vote should not be recorded
        assert voter not in game.state.vote_box.votes

    @pytest.mark.asyncio
    async def test_cannot_vote_for_dead_player(self):
        """Cannot vote for a dead player."""
        game = Game()
        player_ids = await add_players(game, 5)
        await game.start()
        
        game.state.phase = Phase.VOTE
        game.state.vote_box.deadline = float('inf')
        
        voter = player_ids[0]
        target = player_ids[1]
        
        # Kill the target
        kill_player(game, target)
        
        await game.cast_vote(voter, target)
        
        # Vote should not be recorded
        assert voter not in game.state.vote_box.votes

    @pytest.mark.asyncio
    async def test_vote_only_during_vote_phase(self):
        """Votes should only be accepted during VOTE phase."""
        game = Game()
        player_ids = await add_players(game, 5)
        await game.start()
        
        # Not in vote phase
        game.state.phase = Phase.NIGHT
        
        voter = player_ids[0]
        target = player_ids[1]
        
        await game.cast_vote(voter, target)
        
        # Vote should not be recorded
        assert voter not in game.state.vote_box.votes


class TestVoteTally:
    """Test vote tallying and elimination."""

    @pytest.mark.asyncio
    async def test_votes_are_recorded(self):
        """Multiple votes should be recorded correctly."""
        game = Game()
        player_ids = await add_players(game, 5)
        await game.start()
        
        game.state.phase = Phase.VOTE
        game.state.vote_box.deadline = float('inf')
        
        # All vote for player_ids[4]
        for i in range(4):
            await game.cast_vote(player_ids[i], player_ids[4])
        
        assert len(game.state.vote_box.votes) == 4

    @pytest.mark.asyncio
    async def test_player_can_change_vote(self):
        """Player should be able to change their vote."""
        game = Game()
        player_ids = await add_players(game, 5)
        await game.start()
        
        game.state.phase = Phase.VOTE
        game.state.vote_box.deadline = float('inf')
        
        voter = player_ids[0]
        
        # First vote
        await game.cast_vote(voter, player_ids[1])
        assert game.state.vote_box.votes[voter] == player_ids[1]
        
        # Change vote
        await game.cast_vote(voter, player_ids[2])
        assert game.state.vote_box.votes[voter] == player_ids[2]


class TestVotePhaseStart:
    """Test vote phase initialization."""

    @pytest.mark.asyncio
    async def test_vote_box_starts_empty(self):
        """Vote box should start empty."""
        game = Game()
        await add_players(game, 5)
        await game.start()
        
        assert len(game.state.vote_box.votes) == 0

====================================================================================================
PATH: tests\test_win_conditions.py
----------------------------------
"""Tests for win conditions in Loup-Garou."""
from __future__ import annotations

import pytest
from server import Game, Role, Phase
from conftest import add_players, set_player_role, kill_player, get_players_by_role


class TestVillagersWin:
    """Test villagers win condition."""

    @pytest.mark.asyncio
    async def test_villagers_win_when_all_werewolves_dead(self):
        """Villagers should win when all werewolves are eliminated."""
        game = Game()
        player_ids = await add_players(game, 5)
        await game.start()
        
        # Kill all werewolves
        wolves = get_players_by_role(game, Role.WEREWOLF)
        for wolf in wolves:
            kill_player(game, wolf.id)
        
        winner = game._check_winner()
        assert winner == "villagers"

    @pytest.mark.asyncio
    async def test_villagers_win_with_multiple_alive(self):
        """Villagers win should work even with multiple villagers alive."""
        game = Game()
        player_ids = await add_players(game, 8)
        await game.start()
        
        # Kill all werewolves
        wolves = get_players_by_role(game, Role.WEREWOLF)
        for wolf in wolves:
            kill_player(game, wolf.id)
        
        winner = game._check_winner()
        assert winner == "villagers"


class TestWerewolvesWin:
    """Test werewolves win condition."""

    @pytest.mark.asyncio
    async def test_werewolves_win_when_equal_to_nonwolves(self):
        """Werewolves should win when wolves >= non-wolves."""
        game = Game()
        player_ids = await add_players(game, 6)
        await game.start()
        
        # Set up scenario: 1 wolf, 1 non-wolf alive
        # Kill everyone except 1 wolf and 1 villager
        wolves = get_players_by_role(game, Role.WEREWOLF)
        non_wolves = [p for p in game.players.values() if p.role != Role.WEREWOLF]
        
        # Keep 1 wolf alive
        for wolf in wolves[1:]:
            kill_player(game, wolf.id)
        
        # Keep only 1 non-wolf alive
        for nw in non_wolves[1:]:
            kill_player(game, nw.id)
        
        winner = game._check_winner()
        assert winner == "werewolves"

    @pytest.mark.asyncio
    async def test_werewolves_win_when_more_than_nonwolves(self):
        """Werewolves should win when wolves > non-wolves."""
        game = Game()
        player_ids = await add_players(game, 8)  # 2 werewolves
        await game.start()
        
        wolves = get_players_by_role(game, Role.WEREWOLF)
        non_wolves = [p for p in game.players.values() if p.role != Role.WEREWOLF]
        
        # Keep 2 wolves, 1 non-wolf
        for nw in non_wolves[1:]:
            kill_player(game, nw.id)
        
        winner = game._check_winner()
        assert winner == "werewolves"


class TestNobodyWins:
    """Test nobody wins condition."""

    @pytest.mark.asyncio
    async def test_nobody_wins_when_all_dead(self):
        """Nobody should win when all players are dead."""
        game = Game()
        player_ids = await add_players(game, 5)
        await game.start()
        
        # Kill everyone
        for pid in player_ids:
            kill_player(game, pid)
        
        winner = game._check_winner()
        assert winner == "nobody"


class TestGameNotOver:
    """Test that game doesn't end prematurely."""

    @pytest.mark.asyncio
    async def test_no_winner_in_lobby(self):
        """No winner should be declared in LOBBY phase."""
        game = Game()
        await add_players(game, 5)
        
        winner = game._check_winner()
        assert winner is None

    @pytest.mark.asyncio
    async def test_no_winner_when_game_balanced(self):
        """No winner when there are more non-wolves than wolves."""
        game = Game()
        player_ids = await add_players(game, 8)  # 2 werewolves
        await game.start()
        
        # Don't kill anyone - should still be balanced
        winner = game._check_winner()
        assert winner is None

    @pytest.mark.asyncio
    async def test_no_winner_with_one_wolf_and_two_villagers(self):
        """No winner when 1 wolf and 2 non-wolves are alive."""
        game = Game()
        player_ids = await add_players(game, 6)
        await game.start()
        
        wolves = get_players_by_role(game, Role.WEREWOLF)
        non_wolves = [p for p in game.players.values() if p.role != Role.WEREWOLF]
        
        # Keep 1 wolf and 2 non-wolves
        for wolf in wolves[1:]:
            kill_player(game, wolf.id)
        for nw in non_wolves[2:]:
            kill_player(game, nw.id)
        
        winner = game._check_winner()
        assert winner is None

====================================================================================================
PATH: web\player\index.html
---------------------------
<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Loup-Garou</title>
  <link rel="stylesheet" href="/static/game.css">
</head>

<body>
  <div id="app" class="game-app">
    <canvas id="fxCanvas"></canvas>

    <!-- Connection status indicator -->
    <div id="connStatus" class="conn-dot"></div>

    <!-- SCREEN: Join -->
    <div id="screenJoin" class="screen screen-join">
      <div class="screen-content">
        <div class="game-logo">🐺</div>
        <h1>Loup-Garou</h1>
        <p class="subtitle">Rejoins la partie</p>
        <input type="text" id="nameInput" placeholder="Ton prénom" maxlength="24" autocomplete="off">
        <button id="joinBtn" class="btn-primary">Entrer dans le village</button>
      </div>
    </div>

    <!-- SCREEN: Waiting (lobby) -->
    <div id="screenWaiting" class="screen screen-waiting" style="display:none;">
      <div class="screen-content">
        <div class="waiting-icon">⏳</div>
        <h2>En attente</h2>
        <p>La partie va bientôt commencer…</p>
        <div id="playerCount" class="player-count">0 joueurs</div>
      </div>
    </div>

    <!-- SCREEN: Role Reveal -->
    <div id="screenRole" class="screen screen-role" style="display:none;">
      <div class="screen-content">
        <p class="hint">Touche pour révéler ton rôle</p>
        <div id="roleCard" class="role-card" tabindex="0">
          <div class="role-card-inner">
            <div class="role-card-back">
              <img id="cardBackImg" src="/static/cards/verso.jpg" alt="?">
              <span class="tap-hint">👆</span>
            </div>
            <div class="role-card-front">
              <img id="cardFrontImg" src="/static/cards/villager.jpg" alt="Role">
              <div id="roleName" class="role-name">—</div>
            </div>
          </div>
        </div>
        <p id="roleHint" class="role-hint"></p>
      </div>
    </div>

    <!-- SCREEN: Night - Waiting -->
    <div id="screenNightWait" class="screen screen-night" style="display:none;">
      <div class="screen-content">
        <div class="night-icon">🌙</div>
        <h2>La nuit tombe</h2>
        <p id="nightWaitMsg">Ferme les yeux et attends…</p>
      </div>
    </div>

    <!-- SCREEN: Night - Action (pick targets) -->
    <div id="screenNightAction" class="screen screen-night-action" style="display:none;">
      <div class="screen-content">
        <h2 id="actionTitle">Action</h2>
        <p id="actionSubtitle" class="subtitle">Choisis une cible</p>
        <div id="actionTimer" class="action-timer"></div>

        <div id="targets" class="target-grid">
          <!-- Targets inserted here -->
        </div>

        <button id="confirmActionBtn" class="btn-primary" style="display:none;">Confirmer</button>
      </div>
    </div>

    <!-- SCREEN: Day -->
    <div id="screenDay" class="screen screen-day" style="display:none;">
      <div class="screen-content">
        <div class="day-icon">☀️</div>
        <h2>Le jour se lève</h2>
        <p id="dayMsg" class="subtitle">Discutez entre vous...</p>
        <div id="dayTimer" class="day-timer"></div>
      </div>
    </div>

    <!-- SCREEN: Vote -->
    <div id="screenVote" class="screen screen-vote" style="display:none;">
      <div class="screen-content">
        <h2>⚖️ Vote du village</h2>
        <p class="subtitle">Qui doit être éliminé ?</p>
        <div id="voteTimer" class="vote-timer"></div>

        <div id="voteTargets" class="target-grid">
          <!-- Vote targets -->
        </div>

        <div id="voteStatus" class="vote-status"></div>
      </div>
    </div>

    <!-- SCREEN: Result -->
    <div id="screenResult" class="screen screen-result" style="display:none;">
      <div class="screen-content">
        <div class="result-icon">📣</div>
        <h2>Résultat du vote</h2>
        <div id="resultMsg" class="subtitle">—</div>

        <button id="continueBtn" class="btn-primary">Continuer</button>
      </div>
    </div>

    <!-- SCREEN: Game Over -->
    <div id="screenGameOver" class="screen screen-gameover" style="display:none;">
      <div class="screen-content">
        <div class="gameover-icon">🏆</div>
        <h2>Fin de partie</h2>
        <div id="winnerMsg" class="subtitle">—</div>

        <button id="backToJoinBtn" class="btn-primary">Nouvelle partie</button>
      </div>
    </div>

    <!-- SCREEN: Dead -->
    <div id="screenDead" class="screen screen-dead" style="display:none;">
      <div class="screen-content">
        <div class="dead-icon">💀</div>
        <h2>Tu es mort</h2>
        <p class="subtitle">Observe en silence…</p>
      </div>
    </div>

    <!-- Floating role button (mini card) -->
    <button id="roleBtn" class="role-btn" style="display:none;" aria-label="Voir mon rôle">
      <img id="roleBtnImg" src="/static/cards/verso.jpg" alt="Role">
    </button>

    <!-- Hold-to-reveal overlay (centered role while holding) -->
    <div id="rolePeek" class="role-peek" aria-hidden="true">
      <div class="role-peek-card">
        <img id="rolePeekImg" src="/static/cards/verso.jpg" alt="Mon rôle">
      </div>
    </div>

    <!-- Modal for reveals -->
    <div id="modal" class="modal">
      <div class="modal-content">
        <h3 id="modalTitle"></h3>
        <div id="modalBody"></div>
        <button id="modalClose" class="btn-secondary">OK</button>
      </div>
    </div>
  </div>

  <script src="/static/game.js"></script>
</body>

</html>

====================================================================================================
PATH: web\static\game.css
-------------------------
/* Loup-Garou Game UI - Immersive Mobile-First Design */
:root {
  --bg-dark: #0a0908;
  --bg-night: #0d1117;
  --bg-day: #1a1512;
  --surface: rgba(255,255,255,0.06);
  --surface-hover: rgba(255,255,255,0.12);
  --border: rgba(255,255,255,0.1);
  --text: #f5f0e8;
  --text-dim: rgba(245,240,232,0.6);
  --accent: #d4a24c;
  --danger: #c0392b;
  --success: #27ae60;
  --wolf: #8b0000;
  --villager: #2c5f2d;
  --font: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
  --radius: 16px;
  --radius-lg: 24px;
}

* { box-sizing: border-box; margin: 0; padding: 0; }

html, body {
  height: 100%;
  font-family: var(--font);
  background: var(--bg-dark);
  color: var(--text);
  overflow: hidden;
  -webkit-tap-highlight-color: transparent;
  user-select: none;
}

.game-app {
  position: relative;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

#fxCanvas {
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.6;
  z-index: 0;
}

/* Connection indicator */
.conn-dot {
  position: fixed;
  top: 16px;
  right: 16px;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: #e74c3c;
  z-index: 100;
  transition: background 0.3s;
}
.conn-dot.connected { background: #27ae60; }

/* Screens */
.screen {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 24px;
  z-index: 1;
  animation: fadeIn 0.4s ease;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

.screen-content {
  width: 100%;
  max-width: 400px;
  text-align: center;
}

/* Join Screen */
.screen-join { background: linear-gradient(180deg, #1a1512 0%, #0a0908 100%); }
.game-logo { font-size: 80px; margin-bottom: 16px; filter: drop-shadow(0 4px 20px rgba(0,0,0,0.5)); }
.screen-join h1 { font-size: 36px; font-weight: 800; margin-bottom: 8px; letter-spacing: 2px; }
.subtitle { color: var(--text-dim); margin-bottom: 32px; }

input[type="text"] {
  width: 100%;
  padding: 16px 20px;
  font-size: 18px;
  border: 2px solid var(--border);
  border-radius: var(--radius);
  background: var(--surface);
  color: var(--text);
  text-align: center;
  outline: none;
  transition: border-color 0.2s;
}
input[type="text"]:focus { border-color: var(--accent); }
input[type="text"]::placeholder { color: var(--text-dim); }

.btn-primary, .btn-secondary {
  width: 100%;
  padding: 16px 24px;
  font-size: 16px;
  font-weight: 700;
  border: none;
  border-radius: var(--radius);
  cursor: pointer;
  transition: transform 0.1s, opacity 0.2s;
}
.btn-primary {
  background: linear-gradient(135deg, var(--accent), #b8860b);
  color: #1a1512;
  margin-top: 16px;
}
.btn-primary:active { transform: scale(0.98); }
.btn-primary:disabled { opacity: 0.5; }

.btn-secondary {
  background: var(--surface);
  color: var(--text);
  border: 1px solid var(--border);
  margin-top: 12px;
}

/* Waiting Screen */
.screen-waiting { background: var(--bg-dark); }
.waiting-icon { font-size: 64px; margin-bottom: 16px; animation: pulse 2s infinite; }
@keyframes pulse {
  0%, 100% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.1); opacity: 0.8; }
}
.player-count {
  margin-top: 24px;
  padding: 12px 24px;
  background: var(--surface);
  border-radius: var(--radius);
  font-size: 18px;
  font-weight: 600;
}

/* Role Card */
.screen-role { background: radial-gradient(ellipse at center, #1a1512 0%, #0a0908 100%); }
.hint { color: var(--text-dim); margin-bottom: 24px; font-size: 14px; }

.role-card {
  width: 240px;
  height: 340px;
  margin: 0 auto;
  perspective: 1000px;
  cursor: pointer;
}
.role-card-inner {
  position: relative;
  width: 100%;
  height: 100%;
  transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
  transform-style: preserve-3d;
}
.role-card.flipped .role-card-inner { transform: rotateY(180deg); }

.role-card-back, .role-card-front {
  position: absolute;
  inset: 0;
  border-radius: var(--radius-lg);
  backface-visibility: hidden;
  overflow: hidden;
  box-shadow: 0 20px 60px rgba(0,0,0,0.6);
  border: 2px solid rgba(255,255,255,0.1);
}
.role-card-back img, .role-card-front img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}
.role-card-front { transform: rotateY(180deg); }
.tap-hint {
  position: absolute;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 32px;
  animation: bounce 1s infinite;
}
@keyframes bounce {
  0%, 100% { transform: translateX(-50%) translateY(0); }
  50% { transform: translateX(-50%) translateY(-10px); }
}
.role-name {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 16px;
  background: linear-gradient(transparent, rgba(0,0,0,0.9));
  font-size: 20px;
  font-weight: 700;
  text-align: center;
}
.role-hint {
  margin-top: 24px;
  color: var(--text-dim);
  font-size: 14px;
  min-height: 40px;
}

/* Night Screens */
.screen-night, .screen-night-action {
  background: linear-gradient(180deg, #0d1520 0%, #050810 100%);
}
.night-icon { font-size: 64px; margin-bottom: 16px; }

/* Target Grid - Clickable Avatars */
.target-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 12px;
  margin-top: 24px;
  max-height: 50vh;
  overflow-y: auto;
  padding: 4px;
}

.target-card {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 16px 8px;
  background: var(--surface);
  border: 2px solid transparent;
  border-radius: var(--radius);
  cursor: pointer;
  transition: all 0.2s;
}
.target-card:hover { background: var(--surface-hover); }
.target-card.selected {
  border-color: var(--accent);
  background: rgba(212, 162, 76, 0.15);
  transform: scale(1.05);
}
.target-card.voted {
  border-color: var(--success);
  background: rgba(39, 174, 96, 0.15);
}

.target-avatar {
  width: 56px;
  height: 56px;
  border-radius: 50%;
  background: linear-gradient(135deg, #3a3a3a, #2a2a2a);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
  font-weight: 700;
  margin-bottom: 8px;
  border: 2px solid var(--border);
  overflow: hidden;
}
.target-avatar img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}
.target-name {
  font-size: 13px;
  font-weight: 600;
  color: var(--text);
  text-align: center;
  word-break: break-word;
}
.target-card.is-wolf .target-avatar { border-color: var(--wolf); }

/* Action Timer */
.action-timer, .day-timer, .vote-timer {
  font-size: 48px;
  font-weight: 800;
  margin: 16px 0;
  font-variant-numeric: tabular-nums;
}
.action-timer.urgent, .vote-timer.urgent { color: var(--danger); animation: pulse 0.5s infinite; }

.action-desc {
  color: var(--text-dim);
  margin-bottom: 8px;
  font-size: 15px;
}

/* Day Screen */
.screen-day { background: linear-gradient(180deg, #2c2416 0%, #1a1512 100%); }
.day-icon { font-size: 64px; margin-bottom: 16px; }

.death-announcement {
  margin-top: 24px;
  padding: 20px;
  background: rgba(192, 57, 43, 0.2);
  border: 1px solid var(--danger);
  border-radius: var(--radius);
}
.death-announcement .victim-name {
  font-size: 24px;
  font-weight: 700;
  margin-bottom: 8px;
}
.death-announcement .victim-role {
  color: var(--text-dim);
}

/* Vote Screen */
.screen-vote { background: linear-gradient(180deg, #1a1512 0%, #0a0908 100%); }
.vote-confirm {
  margin-top: 20px;
  padding: 12px;
  background: rgba(39, 174, 96, 0.2);
  border-radius: var(--radius);
  color: var(--success);
  font-weight: 600;
}

/* Result Screen */
.screen-result { background: var(--bg-dark); }
.eliminated-player {
  margin-top: 24px;
  padding: 24px;
  background: var(--surface);
  border-radius: var(--radius-lg);
}
.eliminated-player .name {
  font-size: 28px;
  font-weight: 700;
  margin-bottom: 8px;
}
.eliminated-player .role {
  color: var(--text-dim);
  font-size: 18px;
}
.eliminated-player img {
  width: 120px;
  height: 120px;
  border-radius: var(--radius);
  margin-bottom: 16px;
  object-fit: cover;
}

/* Game Over */
.screen-gameover { background: radial-gradient(ellipse at center, #1a1512 0%, #0a0908 100%); }
.gameover-icon { font-size: 80px; margin-bottom: 16px; }
.screen-gameover h2 { font-size: 32px; margin-bottom: 12px; }

.final-roles {
  margin-top: 24px;
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 8px;
  max-height: 40vh;
  overflow-y: auto;
}
.final-role-card {
  padding: 12px;
  background: var(--surface);
  border-radius: var(--radius);
  text-align: center;
}
.final-role-card .name { font-weight: 600; font-size: 14px; }
.final-role-card .role { font-size: 12px; color: var(--text-dim); }
.final-role-card.is-wolf { border-left: 3px solid var(--wolf); }
.final-role-card.is-villager { border-left: 3px solid var(--villager); }

/* Dead Screen */
.screen-dead { background: linear-gradient(180deg, #1a1512 0%, #0a0908 100%); }
.dead-icon { font-size: 80px; margin-bottom: 16px; opacity: 0.6; }

/* Floating Role Button */
.role-btn {
  position: fixed;
  bottom: 24px;
  right: 24px;
  width: 64px;
  height: 64px;
  border: none;
  border-radius: 14px;
  background: none;
  cursor: pointer;
  z-index: 50;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4);
  overflow: hidden;
  transition: transform 0.2s;
}
.role-btn:active { transform: scale(0.95); }
.role-btn img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: 12px;
}

/* Hold-to-reveal centered role (only while holding) */
.role-peek{
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.55);
  z-index: 180;
}
.role-peek.open{ display: flex; }

.role-peek-card{
  width: min(260px, 70vw);
  height: min(260px, 70vw);
  border-radius: 22px;
  overflow: hidden;
  border: 2px solid rgba(255,255,255,0.14);
  box-shadow: 0 24px 80px rgba(0,0,0,0.65);
  background: rgba(0,0,0,0.2);
}
.role-peek-card img{
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}

/* Modal */
.modal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.8);
  display: none;
  align-items: center;
  justify-content: center;
  padding: 24px;
  z-index: 200;
}
.modal.open { display: flex; }
.modal-content {
  width: 100%;
  max-width: 360px;
  padding: 24px;
  background: #1a1512;
  border-radius: var(--radius-lg);
  border: 1px solid var(--border);
  text-align: center;
  animation: modalIn 0.3s ease;
}
@keyframes modalIn {
  from { opacity: 0; transform: scale(0.9); }
  to { opacity: 1; transform: scale(1); }
}
.modal-content h3 { margin-bottom: 16px; font-size: 20px; }
.modal-content img {
  width: 160px;
  height: 160px;
  border-radius: var(--radius);
  margin-bottom: 16px;
  object-fit: cover;
}
#modalClose { margin-top: 16px; }

/* Wolves: show team */
.wolves-team {
  margin-top: 16px;
  padding: 12px;
  background: rgba(139, 0, 0, 0.2);
  border-radius: var(--radius);
  border: 1px solid var(--wolf);
}
.wolves-team-title {
  font-size: 12px;
  color: var(--text-dim);
  margin-bottom: 8px;
  text-transform: uppercase;
  letter-spacing: 1px;
}
.wolves-team-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  justify-content: center;
}
.wolf-badge {
  padding: 6px 12px;
  background: var(--wolf);
  border-radius: 20px;
  font-size: 13px;
  font-weight: 600;
}

/* Cupid: two selections */
.cupid-selections {
  display: flex;
  gap: 16px;
  justify-content: center;
  margin-bottom: 16px;
}
.cupid-slot {
  width: 80px;
  height: 100px;
  border: 2px dashed var(--border);
  border-radius: var(--radius);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  color: var(--text-dim);
}
.cupid-slot.filled {
  border-style: solid;
  border-color: var(--accent);
  background: rgba(212, 162, 76, 0.1);
}
.cupid-slot .slot-avatar {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  background: var(--surface);
  margin-bottom: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  font-weight: 700;
}
.cupid-slot .slot-name {
  font-size: 11px;
  text-align: center;
  word-break: break-word;
}

/* Witch potions */
.witch-potions {
  display: flex;
  gap: 16px;
  justify-content: center;
  margin-bottom: 20px;
}
.potion-btn {
  flex: 1;
  max-width: 140px;
  padding: 16px;
  border: 2px solid var(--border);
  border-radius: var(--radius);
  background: var(--surface);
  cursor: pointer;
  transition: all 0.2s;
}
.potion-btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}
.potion-btn.selected {
  border-color: var(--accent);
  background: rgba(212, 162, 76, 0.15);
}
.potion-btn .potion-icon { font-size: 32px; margin-bottom: 8px; }
.potion-btn .potion-label { font-size: 12px; color: var(--text-dim); }

.witch-victim {
  padding: 12px;
  background: rgba(192, 57, 43, 0.2);
  border-radius: var(--radius);
  margin-bottom: 16px;
}
.witch-victim-label { font-size: 12px; color: var(--text-dim); margin-bottom: 4px; }
.witch-victim-name { font-size: 18px; font-weight: 700; }

/* Responsive */
@media (max-width: 360px) {
  .target-grid { grid-template-columns: repeat(2, 1fr); }
  .role-card { width: 200px; height: 280px; }
}

@media (min-width: 500px) {
  .target-grid { grid-template-columns: repeat(4, 1fr); }
}

/* Scrollbar */
::-webkit-scrollbar { width: 4px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

====================================================================================================
PATH: web\static\game.js
------------------------
/**
 * Loup-Garou - Immersive Game UI
 * Fixed version with working role peek on hold
 */

// Wait for DOM
document.addEventListener('DOMContentLoaded', init);

function init() {
  console.log('[LG] === GAME UI STARTING ===');
  
  // Inject additional styles for witch UI and vote
  const witchStyles = document.createElement('style');
  witchStyles.textContent = `
    .witch-victim-compact {
      text-align: center;
      margin-bottom: 12px;
      font-size: 14px;
    }
    .witch-victim-compact strong {
      color: #ff6b6b;
    }
    .witch-actions-row {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin-bottom: 12px;
    }
    .witch-action-btn {
      padding: 12px 20px;
      background: rgba(0,0,0,0.3);
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 10px;
      color: #f5f0e8;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .witch-action-btn:hover:not(:disabled) {
      border-color: rgba(255,255,255,0.4);
    }
    .witch-action-btn.selected {
      background: rgba(212,162,76,0.3);
      border-color: #d4a24c;
    }
    .witch-action-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    .witch-poison-select {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 8px;
      padding: 12px;
      background: rgba(0,0,0,0.2);
      border-radius: 12px;
      max-height: 200px;
      overflow-y: auto;
    }
    .poison-target-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 14px;
      background: rgba(0,0,0,0.3);
      border: 2px solid rgba(255,255,255,0.15);
      border-radius: 8px;
      color: #f5f0e8;
      cursor: pointer;
      transition: all 0.2s;
    }
    .poison-target-btn:hover {
      border-color: #8b0000;
      background: rgba(139,0,0,0.3);
    }
    .poison-target-btn.selected {
      border-color: #8b0000;
      background: rgba(139,0,0,0.4);
    }
    .poison-target-btn .pt-avatar {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: rgba(255,255,255,0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 12px;
    }
    .poison-target-btn .pt-name {
      font-size: 13px;
    }
    /* Vote confirm button */
    .vote-confirm-btn {
      margin-top: 16px;
      padding: 14px 32px;
      background: linear-gradient(135deg, #8b0000 0%, #5a0000 100%);
      border: none;
      border-radius: 10px;
      color: #f5f0e8;
      font-size: 16px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 4px 20px rgba(139,0,0,0.4);
      transition: all 0.2s;
    }
    .vote-confirm-btn:hover:not(:disabled) {
      transform: scale(1.02);
      box-shadow: 0 6px 28px rgba(139,0,0,0.5);
    }
    .vote-confirm-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .vote-confirmed {
      margin-top: 16px;
      padding: 14px 32px;
      background: rgba(39, 174, 96, 0.2);
      border: 2px solid #27ae60;
      border-radius: 10px;
      color: #27ae60;
      font-size: 16px;
      font-weight: 700;
    }
    /* Ready to vote button */
    .ready-vote-btn {
      margin-top: 24px;
      padding: 16px 32px;
      background: linear-gradient(135deg, #d4a24c 0%, #b8860b 100%);
      border: none;
      border-radius: 12px;
      color: #1a1512;
      font-size: 16px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 4px 20px rgba(212,162,76,0.4);
      transition: all 0.2s;
    }
    .ready-vote-btn:hover:not(:disabled) {
      transform: scale(1.02);
      box-shadow: 0 6px 28px rgba(212,162,76,0.5);
    }
    .ready-vote-btn.ready {
      background: rgba(39, 174, 96, 0.2);
      border: 2px solid #27ae60;
      color: #27ae60;
      box-shadow: none;
    }
    .ready-vote-btn:disabled {
      cursor: default;
    }
  `;
  document.head.appendChild(witchStyles);
  
  // Simple element getter
  const $ = id => {
    const el = document.getElementById(id);
    if (!el) console.warn('[LG] Element not found:', id);
    return el;
  };
  
  // Parse URL params
  const params = new URLSearchParams(window.location.search);
  const config = {
    host: params.get('backendHost') || window.location.hostname,
    port: params.get('backendPort') || window.location.port || '8000',
    playerId: params.get('player_id') || '',
    playerName: params.get('name') || '',
    autoJoin: params.get('autojoin') === '1',
    isBot: params.get('bot') === '1'
  };
  
  // Build URLs - handle case where port might be empty (production)
  const portPart = config.port ? `:${config.port}` : '';
  const API_URL = `${window.location.protocol}//${config.host}${portPart}`;
  const WS_URL = `${window.location.protocol === 'https:' ? 'wss' : 'ws'}://${config.host}${portPart}`;
  
  console.log('[LG] Config:', config);
  console.log('[LG] API URL:', API_URL);
  
  // Game state
  let state = {
    phase: 'LOBBY',
    me: null,
    alive: [],
    dead: [],
    wolves_team: null,
    wolves_votes: null,
    witch_ctx: null,
    pending_step: null,
    pending_deadline: null,
    timers: null,
    winner: null,
    winner_fr: null,
    lover_name: null
  };
  
  let ws = null;
  let currentScreen = null;
  
  // FX (optional)
  const fx = window.LGFX?.init($('fxCanvas'), { mode: 'night' });
  
  // ============ SCREENS ============
  const allScreens = [
    'screenJoin', 'screenWaiting', 'screenRole', 'screenNightWait',
    'screenNightAction', 'screenDay', 'screenVote', 'screenResult',
    'screenGameOver', 'screenDead'
  ];
  
  function showScreen(screenId) {
    console.log('[LG] Showing screen:', screenId);
    allScreens.forEach(id => {
      const el = $(id);
      if (el) {
        el.style.display = (id === screenId) ? 'flex' : 'none';
      }
    });
    currentScreen = screenId;
    fx?.burst({ kind: 'magic', count: 10 });
  }
  
  // ============ HELPERS ============
  function getRoleImage(role) {
    const images = {
      villager: 'villager.jpg',
      werewolf: 'werewolf.jpg',
      seer: 'voyante.jpg',
      witch: 'sorcerer.jpg',
      cupid: 'cupidon.jpg',
      hunter: 'hunter.jpg'
    };
    return '/static/cards/' + (images[role] || 'verso.jpg');
  }
  
  function getRoleName(role) {
    const names = {
      villager: 'Villageois',
      werewolf: 'Loup-Garou',
      seer: 'Voyante',
      witch: 'Sorcière',
      cupid: 'Cupidon'
    };
    return names[role] || '???';
  }
  
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text || '';
    return div.innerHTML;
  }
  
  function setConnected(connected) {
    const dot = $('connStatus');
    if (dot) {
      dot.classList.toggle('connected', connected);
    }
  }
  
  // ============ JOIN ============
  async function joinGame(name) {
    console.log('[LG] Joining game with name:', name);
    
    try {
      const response = await fetch(API_URL + '/api/join', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: name })
      });
      
      console.log('[LG] Join response status:', response.status);
      
      const data = await response.json();
      console.log('[LG] Join response data:', data);
      
      if (!data.ok) {
        throw new Error(data.error || 'Join failed');
      }
      
      // Save player ID
      config.playerId = data.player_id;
      config.playerName = name;
      
      // Update URL
      const newUrl = new URL(window.location.href);
      newUrl.searchParams.set('player_id', config.playerId);
      newUrl.searchParams.set('name', name);
      window.history.replaceState({}, '', newUrl.toString());
      
      console.log('[LG] Joined! Player ID:', config.playerId);
      
      // Connect WebSocket and show waiting
      connectWebSocket();
      showScreen('screenWaiting');
      
      return true;
    } catch (error) {
      console.error('[LG] Join error:', error);
      alert('Erreur de connexion: ' + error.message);
      return false;
    }
  }
  
  // ============ WEBSOCKET ============
  function connectWebSocket() {
    if (!config.playerId) {
      console.log('[LG] No player ID, skipping WS connect');
      return;
    }
    
    const url = WS_URL + '/ws?client=player&player_id=' + encodeURIComponent(config.playerId);
    console.log('[LG] Connecting WebSocket:', url);
    
    ws = new WebSocket(url);
    
    ws.onopen = () => {
      console.log('[LG] WebSocket connected');
      setConnected(true);
    };
    
    ws.onclose = () => {
      console.log('[LG] WebSocket closed, reconnecting...');
      setConnected(false);
      setTimeout(connectWebSocket, 1500);
    };
    
    ws.onerror = (err) => {
      console.error('[LG] WebSocket error:', err);
      setConnected(false);
    };
    
    ws.onmessage = (event) => {
      try {
        const msg = JSON.parse(event.data);
        handleMessage(msg);
      } catch (e) {
        console.error('[LG] Failed to parse message:', e);
      }
    };
  }
  
  // ============ MESSAGE HANDLING ============
  function handleMessage(msg) {
    console.log('[LG] Message:', msg.type, msg);
    
    switch (msg.type) {
      case 'PUBLIC_STATE':
        state.phase = msg.data.phase;
        state.alive = msg.data.alive || [];
        state.dead = msg.data.dead || [];
        state.timers = msg.data.timers;
        state.started = msg.data.started;
        state.winner = msg.data.winner;
        updateUI();
        break;
        
      case 'PRIVATE_STATE':
        console.log('[LG] PRIVATE_STATE received:', msg.data);
        state.me = msg.data.me;
        state.wolves_team = msg.data.wolves_team;
        state.wolves_votes = msg.data.wolves_votes;
        state.witch_ctx = msg.data.witch_ctx;
        state.pending_step = msg.data.pending_step;
        state.pending_deadline = msg.data.pending_deadline;
        state.lover_name = msg.data.lover_name;
        
        console.log('[LG] My role:', state.me?.role);
        console.log('[LG] Pending step:', state.pending_step);
        
        // Update role button image when we know the role
        updateRoleButton();
        
        // First time seeing role after game started?
        if (state.me?.role && state.started && currentScreen === 'screenWaiting') {
          console.log('[LG] First time seeing role, showing reveal screen');
          showRoleReveal();
        }
        updateUI();
        break;
        
      case 'SEER_RESULT':
        showModal('Vision', `
          <img src="${getRoleImage(msg.role)}" style="width:120px;height:120px;border-radius:12px;">
          <div style="font-size:20px;font-weight:bold;margin-top:12px;">${escapeHtml(msg.target_name)}</div>
          <div style="color:#aaa;">${msg.role_fr || getRoleName(msg.role)}</div>
        `);
        break;
        
      case 'LOVER_ASSIGNED':
        state.lover_name = msg.lover_name;
        showModal('💕 Cupidon', `
          <div style="font-size:48px;">💕</div>
          <div style="margin-top:12px;">Tu es amoureux/amoureuse de</div>
          <div style="font-size:24px;font-weight:bold;color:#d4a24c;">${escapeHtml(msg.lover_name)}</div>
          <div style="margin-top:12px;color:#aaa;font-size:14px;">Si l'un de vous meurt, l'autre meurt aussi de chagrin.</div>
        `);
        break;
        
      case 'WITCH_CONTEXT':
        state.witch_ctx = {
          victim_id: msg.wolves_victim_id,
          victim_name: msg.wolves_victim_name,
          heal_used: msg.heal_used,
          poison_used: msg.poison_used
        };
        break;
        
      case 'VOTE_RESULT':
        showVoteResult(msg);
        break;
        
      case 'GAME_OVER':
        state.winner = msg.winner;
        state.winner_fr = msg.winner_fr;
        state.phase = 'GAME_OVER';
        showGameOver();
        break;
        
      case 'ACTION_REQUEST':
        console.log('[LG] ACTION_REQUEST received:', msg);
        state.pending_step = msg.step;
        state.pending_deadline = msg.deadline;
        updateUI();
        break;
        
      case 'RESET':
        window.location.href = window.location.pathname;
        break;
    }
  }
  
  // ============ ROLE BUTTON ============
  function updateRoleButton() {
    const roleBtn = $('roleBtn');
    if (!roleBtn) return;
    
    // Show button if we have a role and not on join/waiting/role screens
    const shouldShow = state.me?.role && 
                       currentScreen !== 'screenJoin' && 
                       currentScreen !== 'screenRole' &&
                       currentScreen !== 'screenWaiting';
    
    roleBtn.style.display = shouldShow ? 'block' : 'none';
    console.log('[LG] Role button visibility:', shouldShow, 'role:', state.me?.role);
  }
  
  // ============ UI UPDATES ============
  let lastBuiltStep = null;
  let lastPhase = null;
  
  function updateUI() {
    // Update player count in waiting screen
    const countEl = $('playerCount');
    if (countEl) {
      const total = state.alive.length + state.dead.length;
      countEl.textContent = total + ' joueur(s)';
    }
    
    // Update timers
    updateTimers();
    
    // Update role button
    updateRoleButton();
    
    // Dead check
    if (state.me && !state.me.alive && state.phase !== 'GAME_OVER' && state.phase !== 'LOBBY') {
      showScreen('screenDead');
      return;
    }
    
    // Track phase changes
    const phaseChanged = (state.phase !== lastPhase);
    if (phaseChanged) {
      console.log('[LG] Phase changed:', lastPhase, '->', state.phase);
    }
    lastPhase = state.phase;
    
    // Phase-based screens
    if (state.phase === 'LOBBY') {
      if (config.playerId && currentScreen !== 'screenRole' && currentScreen !== 'screenWaiting') {
        showScreen('screenWaiting');
      }
    } else if (state.phase === 'NIGHT') {
      handleNightPhase(phaseChanged);
    } else if (state.phase === 'DAY') {
      showDayScreen(phaseChanged);
    } else if (state.phase === 'VOTE') {
      showVoteScreen(phaseChanged);
    } else if (state.phase === 'GAME_OVER') {
      if (phaseChanged) showGameOver();
    }
  }
  
  function updateTimers() {
    // Update various timer displays
    if (state.timers?.seconds_left != null) {
      const secs = state.timers.seconds_left;
      
      // Day timer
      const dayTimer = $('dayTimer');
      if (dayTimer) {
        dayTimer.textContent = secs + 's';
        dayTimer.classList.toggle('urgent', secs <= 5);
      }
      
      // Vote timer
      const voteTimer = $('voteTimer');
      if (voteTimer) {
        voteTimer.textContent = secs + 's';
        voteTimer.classList.toggle('urgent', secs <= 5);
      }
      
      // Action timer (night actions)
      const actionTimer = $('actionTimer');
      if (actionTimer) {
        actionTimer.textContent = secs + 's';
        actionTimer.classList.toggle('urgent', secs <= 5);
      }
    }
  }
  
  // ============ ROLE REVEAL ============
  function showRoleReveal() {
    showScreen('screenRole');
    
    const frontImg = $('cardFrontImg');
    const roleName = $('roleName');
    const roleHint = $('roleHint');
    const roleCard = $('roleCard');
    
    // Reset card to back
    if (roleCard) roleCard.classList.remove('flipped');
    
    if (frontImg && state.me?.role) {
      frontImg.src = getRoleImage(state.me.role);
    }
    if (roleName && state.me?.role) {
      roleName.textContent = getRoleName(state.me.role);
    }
    
    const hints = {
      werewolf: '🐺 Tu es un Loup-Garou. Dévore les villageois la nuit!',
      seer: '🔮 Tu es la Voyante. Chaque nuit, découvre le rôle d\'un joueur.',
      witch: '🧪 Tu es la Sorcière. Tu as une potion de vie et une de mort.',
      cupid: '💘 Tu es Cupidon. La première nuit, désigne deux amoureux.',
      villager: '🏠 Tu es Villageois. Trouve et élimine les loups!'
    };
    if (roleHint && state.me?.role) {
      roleHint.textContent = hints[state.me.role] || '';
    }
    
    // Show wolves team if werewolf
    if (state.me?.role === 'werewolf' && state.wolves_team && state.wolves_team.length > 1) {
      const teamHtml = state.wolves_team.map(w => `<span class="wolf-badge">${escapeHtml(w.name)}</span>`).join(' ');
      if (roleHint) {
        roleHint.innerHTML = hints.werewolf + `
          <div class="wolves-team" style="margin-top:16px;">
            <div class="wolves-team-title">Ta meute</div>
            <div class="wolves-team-list">${teamHtml}</div>
          </div>
        `;
      }
    }
  }
  
  // ============ NIGHT PHASE ============
  function handleNightPhase(phaseChanged) {
    if (!state.me?.alive) {
      showScreen('screenNightWait');
      return;
    }
    
    const myRole = state.me?.role;
    const step = state.pending_step;
    
    console.log('[LG] handleNightPhase - myRole:', myRole, 'step:', step);
    
    const roleSteps = {
      'WOLVES': 'werewolf',
      'SEER': 'seer',
      'WITCH': 'witch',
      'CUPID': 'cupid'
    };
    
    // Check if it's my turn to act
    const isMyTurn = step && roleSteps[step] === myRole;
    console.log('[LG] Is my turn:', isMyTurn);
    
    if (isMyTurn) {
      // Only rebuild action UI if the step changed
      if (step !== lastBuiltStep || phaseChanged) {
        console.log('[LG] Building action UI for step:', step);
        showScreen('screenNightAction');
        buildActionUI(step);
        lastBuiltStep = step;
      }
    } else {
      // Not my turn - show waiting screen
      if (currentScreen !== 'screenNightWait' && currentScreen !== 'screenRole') {
        showScreen('screenNightWait');
        
        // Update wait message based on current step
        const waitMsg = $('nightWaitMsg');
        if (waitMsg) {
          const messages = {
            'CUPID': 'Cupidon choisit les amoureux...',
            'WOLVES': 'Les loups chassent...',
            'SEER': 'La voyante consulte les esprits...',
            'WITCH': 'La sorcière prépare ses potions...'
          };
          waitMsg.textContent = step ? messages[step] || 'Ferme les yeux et attends…' : 'Ferme les yeux et attends…';
        }
      }
      lastBuiltStep = null;
    }
  }
  
  // ============ ACTION UI ============
  function buildActionUI(step) {
    const title = $('actionTitle');
    const subtitle = $('actionSubtitle');
    const grid = $('targets');  // This is the correct ID from the HTML
    const confirmBtn = $('confirmActionBtn');
    
    console.log('[LG] buildActionUI - step:', step);
    console.log('[LG] Elements found - title:', !!title, 'subtitle:', !!subtitle, 'grid:', !!grid, 'confirmBtn:', !!confirmBtn);
    
    if (!grid) {
      console.error('[LG] Target grid not found!');
      return;
    }
    
    grid.innerHTML = '';
    if (confirmBtn) confirmBtn.style.display = 'none';
    
    const allTargets = state.alive.filter(p => p.id !== config.playerId);
    
    if (step === 'WOLVES') {
      if (title) title.textContent = '🐺 Choisissez une victime';
      if (subtitle) subtitle.textContent = 'Désignez un villageois à dévorer';
      
      // Filter out wolves from targets
      const wolfIds = (state.wolves_team || []).map(w => w.id);
      const validTargets = state.alive.filter(p => !wolfIds.includes(p.id));
      
      console.log('[LG] Wolf targets:', validTargets.length);
      
      // Show current wolf votes if any
      if (state.wolves_votes && Object.keys(state.wolves_votes).length > 0) {
        const voteCounts = {};
        Object.values(state.wolves_votes).forEach(targetId => {
          if (targetId) {
            voteCounts[targetId] = (voteCounts[targetId] || 0) + 1;
          }
        });
        
        buildTargetGrid(grid, validTargets, (id) => {
          submitAction('WOLVES', { target: id });
          markSelected(grid, id);
        }, voteCounts);
      } else {
        buildTargetGrid(grid, validTargets, (id) => {
          submitAction('WOLVES', { target: id });
          markSelected(grid, id);
        });
      }
      
    } else if (step === 'SEER') {
      if (title) title.textContent = '🔮 Consulte les esprits';
      if (subtitle) subtitle.textContent = 'Choisis un joueur à révéler';
      
      let selectedId = null;
      buildTargetGrid(grid, allTargets, (id) => {
        selectedId = id;
        markSelected(grid, id);
        if (confirmBtn) confirmBtn.style.display = 'block';
      });
      
      if (confirmBtn) {
        confirmBtn.textContent = 'Révéler';
        confirmBtn.onclick = () => {
          if (selectedId) {
            submitAction('SEER', { target: selectedId });
            grid.innerHTML = '<div style="color:#888;padding:20px;">🔮 Vision en cours...</div>';
            confirmBtn.style.display = 'none';
          }
        };
      }
      
    } else if (step === 'WITCH') {
      if (title) title.textContent = '🧪 Tes potions magiques';
      
      // Build compact witch UI
      const canHeal = !state.me?.witch_heal_used && state.witch_ctx?.victim_name;
      const canPoison = !state.me?.witch_poison_used;
      
      let subtitleHtml = '';
      
      // Show victim info compactly
      if (state.witch_ctx?.victim_name) {
        subtitleHtml += `<div class="witch-victim-compact">Victime des loups: <strong>${escapeHtml(state.witch_ctx.victim_name)}</strong></div>`;
      } else {
        subtitleHtml += `<div class="witch-victim-compact" style="color:#888;">Aucune victime cette nuit</div>`;
      }
      
      // Horizontal buttons
      subtitleHtml += `
        <div class="witch-actions-row">
          <button id="witchHealBtn" class="witch-action-btn" ${canHeal ? '' : 'disabled'}>
            💚 ${state.me?.witch_heal_used ? 'Utilisée' : 'Sauver'}
          </button>
          <button id="witchPoisonBtn" class="witch-action-btn" ${canPoison ? '' : 'disabled'}>
            💀 ${state.me?.witch_poison_used ? 'Utilisée' : 'Poison'}
          </button>
        </div>
        <div id="witchPoisonSelect" class="witch-poison-select" style="display:none;"></div>
      `;
      
      if (subtitle) subtitle.innerHTML = subtitleHtml;
      
      let useHeal = false;
      let poisonTarget = null;
      
      setTimeout(() => {
        const healBtn = $('witchHealBtn');
        const poisonBtn = $('witchPoisonBtn');
        const poisonSelect = $('witchPoisonSelect');
        
        if (healBtn && canHeal) {
          healBtn.onclick = () => {
            useHeal = !useHeal;
            healBtn.classList.toggle('selected', useHeal);
          };
        }
        
        if (poisonBtn && canPoison && poisonSelect) {
          poisonBtn.onclick = () => {
            const isOpen = poisonSelect.style.display !== 'none';
            if (isOpen) {
              poisonSelect.style.display = 'none';
              if (!poisonTarget) poisonBtn.classList.remove('selected');
            } else {
              poisonBtn.classList.add('selected');
              poisonSelect.style.display = 'block';
              // Build horizontal scrollable list
              poisonSelect.innerHTML = allTargets.map(p => 
                `<button class="poison-target-btn ${poisonTarget === p.id ? 'selected' : ''}" data-id="${p.id}">
                  <span class="pt-avatar">${(p.name||'?')[0].toUpperCase()}</span>
                  <span class="pt-name">${escapeHtml(p.name)}</span>
                </button>`
              ).join('');
              
              // Attach click handlers
              poisonSelect.querySelectorAll('.poison-target-btn').forEach(btn => {
                btn.onclick = () => {
                  poisonTarget = btn.dataset.id;
                  poisonSelect.querySelectorAll('.poison-target-btn').forEach(b => b.classList.remove('selected'));
                  btn.classList.add('selected');
                  // Auto-collapse after selection
                  setTimeout(() => {
                    poisonSelect.style.display = 'none';
                  }, 300);
                };
              });
            }
          };
        }
      }, 10);
      
      if (confirmBtn) {
        confirmBtn.style.display = 'block';
        confirmBtn.textContent = 'Valider';
        confirmBtn.onclick = () => {
          submitAction('WITCH', { heal: useHeal, poison_target: poisonTarget });
          if (subtitle) subtitle.innerHTML = '<div style="color:#888;padding:20px;">✨ Potions utilisées...</div>';
          grid.innerHTML = '';
          confirmBtn.style.display = 'none';
        };
      }
      
    } else if (step === 'CUPID') {
      if (title) title.textContent = '💘 Désigne les amoureux';
      if (subtitle) {
        subtitle.innerHTML = `
          <div style="margin-bottom:16px;">Choisis deux joueurs qui seront liés par l'amour.</div>
          <div class="cupid-selections">
            <div id="cupidSlot1" class="cupid-slot">
              <div class="slot-avatar">1</div>
              <div class="slot-name">---</div>
            </div>
            <div id="cupidSlot2" class="cupid-slot">
              <div class="slot-avatar">2</div>
              <div class="slot-name">---</div>
            </div>
          </div>
        `;
      }
      
      let lovers = [];
      
      // Cupid can choose anyone including themselves
      buildTargetGrid(grid, state.alive, (id, name) => {
        const idx = lovers.indexOf(id);
        if (idx >= 0) {
          lovers.splice(idx, 1);
        } else if (lovers.length < 2) {
          lovers.push(id);
        }
        
        // Update slots
        const slot1 = $('cupidSlot1');
        const slot2 = $('cupidSlot2');
        const getName = (lid) => state.alive.find(p => p.id === lid)?.name || '?';
        
        if (slot1) {
          if (lovers[0]) {
            slot1.classList.add('filled');
            slot1.innerHTML = `
              <div class="slot-avatar">${getName(lovers[0])[0].toUpperCase()}</div>
              <div class="slot-name">${escapeHtml(getName(lovers[0]))}</div>
            `;
          } else {
            slot1.classList.remove('filled');
            slot1.innerHTML = `<div class="slot-avatar">1</div><div class="slot-name">---</div>`;
          }
        }
        
        if (slot2) {
          if (lovers[1]) {
            slot2.classList.add('filled');
            slot2.innerHTML = `
              <div class="slot-avatar">${getName(lovers[1])[0].toUpperCase()}</div>
              <div class="slot-name">${escapeHtml(getName(lovers[1]))}</div>
            `;
          } else {
            slot2.classList.remove('filled');
            slot2.innerHTML = `<div class="slot-avatar">2</div><div class="slot-name">---</div>`;
          }
        }
        
        // Update selection visual
        grid.querySelectorAll('.target-card').forEach(card => {
          card.classList.toggle('selected', lovers.includes(card.dataset.id));
        });
        
        if (confirmBtn) confirmBtn.style.display = lovers.length === 2 ? 'block' : 'none';
      });
      
      if (confirmBtn) {
        confirmBtn.textContent = '💕 Unir ces âmes';
        confirmBtn.onclick = () => {
          if (lovers.length === 2) {
            submitAction('CUPID', { targets: lovers });
            grid.innerHTML = '<div style="color:#888;padding:20px;">💕 Amoureux désignés!</div>';
            if (subtitle) subtitle.innerHTML = '<div style="font-size:48px;">💕</div>';
            confirmBtn.style.display = 'none';
          }
        };
      }
    }
  }
  
  function buildTargetGrid(container, players, onClick, voteCounts = {}) {
    container.innerHTML = '';
    
    players.forEach(p => {
      const card = document.createElement('div');
      card.className = 'target-card';
      card.dataset.id = p.id;
      
      // Check if this is a wolf teammate
      const isWolf = state.wolves_team?.some(w => w.id === p.id);
      if (isWolf) card.classList.add('is-wolf');
      
      // Show vote count if any
      const votes = voteCounts[p.id] || 0;
      const voteBadge = votes > 0 ? `<div style="position:absolute;top:-8px;right:-8px;background:#d4a24c;color:#000;border-radius:50%;width:24px;height:24px;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:12px;">${votes}</div>` : '';
      
      card.innerHTML = `
        <div class="target-avatar" style="position:relative;">
          ${(p.name || '?')[0].toUpperCase()}
          ${voteBadge}
        </div>
        <div class="target-name">${escapeHtml(p.name)}</div>
      `;
      card.addEventListener('click', () => onClick(p.id, p.name));
      container.appendChild(card);
    });
  }
  
  function markSelected(container, id) {
    container.querySelectorAll('.target-card').forEach(card => {
      card.classList.toggle('selected', card.dataset.id === id);
    });
  }
  
  async function submitAction(step, data) {
    console.log('[LG] Submitting action:', step, data);
    try {
      const res = await fetch(API_URL + '/api/action', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ player_id: config.playerId, step: step, data: data })
      });
      const result = await res.json();
      console.log('[LG] Action result:', result);
    } catch (e) {
      console.error('[LG] Action failed:', e);
    }
  }
  
  // ============ VOTE ============
  let voteGridBuilt = false;
  let hasVoted = false;
  let selectedVoteTarget = null;
  let selectedVoteName = null;
  
  function showVoteScreen(phaseChanged) {
    if (phaseChanged) {
      voteGridBuilt = false;
      hasVoted = false;
      selectedVoteTarget = null;
      selectedVoteName = null;
    }
    
    if (currentScreen !== 'screenVote') {
      showScreen('screenVote');
    }
    
    // Only build grid once per vote phase
    if (voteGridBuilt) return;
    voteGridBuilt = true;
    
    const grid = $('voteTargets');
    const status = $('voteStatus');
    
    if (!grid) {
      console.error('[LG] Vote targets grid not found!');
      return;
    }
    
    console.log('[LG] Building vote grid with confirmation');
    
    // Can vote for anyone alive except yourself
    const targets = state.alive.filter(p => p.id !== config.playerId);
    
    // Build grid manually without auto-submit
    grid.innerHTML = '';
    targets.forEach(p => {
      const card = document.createElement('div');
      card.className = 'target-card';
      card.dataset.id = p.id;
      card.innerHTML = `
        <div class="target-avatar">${(p.name || '?')[0].toUpperCase()}</div>
        <div class="target-name">${escapeHtml(p.name)}</div>
      `;
      
      card.addEventListener('click', () => {
        if (hasVoted) return;
        
        // Select this target
        selectedVoteTarget = p.id;
        selectedVoteName = p.name;
        
        // Update visual selection
        grid.querySelectorAll('.target-card').forEach(c => c.classList.remove('selected'));
        card.classList.add('selected');
        
        // Show/update confirm button
        if (status) {
          status.innerHTML = `
            <button id="confirmVoteBtn" class="vote-confirm-btn">
              ⚔️ Voter contre ${escapeHtml(p.name)}
            </button>
          `;
          
          $('confirmVoteBtn').addEventListener('click', submitVote);
        }
      });
      
      grid.appendChild(card);
    });
    
    // Initial status
    if (status) {
      status.innerHTML = '<div style="color:#888;font-size:14px;">Sélectionne un joueur puis confirme ton vote</div>';
    }
  }
  
  async function submitVote() {
    if (hasVoted || !selectedVoteTarget) return;
    
    const btn = $('confirmVoteBtn');
    const status = $('voteStatus');
    
    if (btn) {
      btn.disabled = true;
      btn.textContent = 'Envoi du vote...';
    }
    
    try {
      const res = await fetch(API_URL + '/api/vote', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ voter_id: config.playerId, target_id: selectedVoteTarget })
      });
      const data = await res.json();
      console.log('[LG] Vote result:', data);
      
      if (data.ok) {
        hasVoted = true;
        if (status) {
          status.innerHTML = `<div class="vote-confirmed">✅ Tu as voté contre ${escapeHtml(selectedVoteName)}</div>`;
        }
      } else {
        throw new Error(data.error || 'Vote failed');
      }
    } catch (e) {
      console.error('[LG] Vote failed:', e);
      if (btn) {
        btn.disabled = false;
        btn.textContent = `⚔️ Voter contre ${escapeHtml(selectedVoteName)}`;
      }
    }
  }
  
  // ============ DAY PHASE - Ready to Vote ============
  let readyToVote = false;
  
  function showDayScreen(phaseChanged) {
    if (phaseChanged) {
      readyToVote = false;
    }
    
    if (currentScreen !== 'screenDay') {
      showScreen('screenDay');
    }
    
    // Add ready to vote button if not already there
    const dayContent = document.querySelector('#screenDay .screen-content');
    let readyBtn = $('readyToVoteBtn');
    
    if (!readyBtn && dayContent) {
      const btnHtml = `
        <button id="readyToVoteBtn" class="ready-vote-btn">
          🗳️ Je suis prêt à voter
        </button>
      `;
      dayContent.insertAdjacentHTML('beforeend', btnHtml);
      readyBtn = $('readyToVoteBtn');
      
      if (readyBtn) {
        readyBtn.addEventListener('click', () => {
          readyToVote = true;
          readyBtn.classList.add('ready');
          readyBtn.innerHTML = '✅ En attente du vote...';
          readyBtn.disabled = true;
          
          // Optionally notify server (could track ready players)
          // For now just visual feedback
        });
      }
    }
    
    // Update ready button state
    if (readyBtn && readyToVote) {
      readyBtn.classList.add('ready');
      readyBtn.innerHTML = '✅ En attente du vote...';
      readyBtn.disabled = true;
    }
  }
  
  function showVoteResult(msg) {
    showScreen('screenResult');
    const resultMsg = $('resultMsg');
    
    if (resultMsg) {
      if (msg.eliminated) {
        resultMsg.innerHTML = `
          <div style="margin-bottom:16px;">Le village a décidé...</div>
          <div style="font-size:24px;font-weight:bold;margin-bottom:8px;">${escapeHtml(msg.eliminated.name)}</div>
          <div style="color:#aaa;margin-bottom:16px;">a été éliminé</div>
          <img src="${getRoleImage(msg.eliminated.role)}" style="width:120px;height:120px;border-radius:12px;margin-bottom:12px;">
          <div style="color:#d4a24c;">${msg.eliminated.role_fr || getRoleName(msg.eliminated.role)}</div>
        `;
      } else {
        resultMsg.innerHTML = `
          <div style="font-size:24px;font-weight:bold;">Pas d'élimination</div>
          <div style="color:#aaa;">Le village n'a pas réussi à se décider.</div>
        `;
      }
    }
  }
  
  // Continue button on result screen
  const continueBtn = $('continueBtn');
  if (continueBtn) {
    continueBtn.addEventListener('click', () => {
      // Just go back to waiting - the server will drive the next phase
      if (state.phase === 'NIGHT') {
        showScreen('screenNightWait');
      } else if (state.phase === 'DAY') {
        showScreen('screenDay');
      }
    });
  }
  
  // ============ GAME OVER ============
  function showGameOver() {
    showScreen('screenGameOver');
    
    const winnerMsg = $('winnerMsg');
    const icon = document.querySelector('#screenGameOver .gameover-icon');
    
    if (winnerMsg) {
      if (state.winner === 'werewolves') {
        if (icon) icon.textContent = '🐺';
        winnerMsg.innerHTML = `
          <div style="font-size:28px;font-weight:bold;color:#8b0000;">Les Loups-Garous</div>
          <div style="color:#aaa;margin-top:8px;">ont dévoré le village!</div>
        `;
      } else if (state.winner === 'villagers') {
        if (icon) icon.textContent = '🏆';
        winnerMsg.innerHTML = `
          <div style="font-size:28px;font-weight:bold;color:#27ae60;">Les Villageois</div>
          <div style="color:#aaa;margin-top:8px;">ont éliminé tous les loups!</div>
        `;
      } else {
        if (icon) icon.textContent = '💀';
        winnerMsg.innerHTML = `
          <div style="font-size:28px;font-weight:bold;">Personne</div>
          <div style="color:#aaa;margin-top:8px;">Tout le monde est mort...</div>
        `;
      }
    }
    
    fx?.burst({ kind: 'magic', count: 30 });
  }
  
  // Back to join button
  const backToJoinBtn = $('backToJoinBtn');
  if (backToJoinBtn) {
    backToJoinBtn.addEventListener('click', () => {
      window.location.href = window.location.pathname;
    });
  }
  
  // ============ MODAL ============
  function showModal(title, content) {
    const modal = $('modal');
    const titleEl = $('modalTitle');
    const bodyEl = $('modalBody');
    
    if (titleEl) titleEl.textContent = title;
    if (bodyEl) bodyEl.innerHTML = content;
    if (modal) modal.classList.add('open');
    
    fx?.burst({ kind: 'spark', count: 15 });
  }
  
  function closeModal() {
    const modal = $('modal');
    if (modal) modal.classList.remove('open');
  }
  
  // ============ EVENT LISTENERS ============
  
  // Join button
  const joinBtn = $('joinBtn');
  const nameInput = $('nameInput');
  
  console.log('[LG] Join elements found:', !!joinBtn, !!nameInput);
  
  if (joinBtn) {
    joinBtn.addEventListener('click', async function() {
      console.log('[LG] JOIN BUTTON CLICKED!');
      
      const name = nameInput ? nameInput.value.trim() : '';
      console.log('[LG] Name value:', name);
      
      if (!name) {
        if (nameInput) {
          nameInput.focus();
          nameInput.style.borderColor = '#c0392b';
          setTimeout(() => { nameInput.style.borderColor = ''; }, 1000);
        }
        return;
      }
      
      joinBtn.disabled = true;
      joinBtn.textContent = 'Connexion...';
      
      const success = await joinGame(name);
      
      if (!success) {
        joinBtn.disabled = false;
        joinBtn.textContent = 'Entrer dans le village';
      }
    });
  }
  
  if (nameInput) {
    nameInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter' && joinBtn) {
        joinBtn.click();
      }
    });
  }
  
  // Role card flip
  const roleCard = $('roleCard');
  if (roleCard) {
    roleCard.addEventListener('click', function() {
      roleCard.classList.toggle('flipped');
      fx?.burst({ kind: 'spark', count: 12 });
    });
  }
  
  // ============ ROLE PEEK (HOLD TO REVEAL) ============
  const roleBtn = $('roleBtn');
  const rolePeek = $('rolePeek');
  const rolePeekImg = $('rolePeekImg');
  const roleBtnImg = $('roleBtnImg');
  
  console.log('[LG] Role peek elements:', {
    roleBtn: !!roleBtn,
    rolePeek: !!rolePeek,
    rolePeekImg: !!rolePeekImg,
    roleBtnImg: !!roleBtnImg
  });
  
  if (roleBtn && rolePeek && rolePeekImg) {
    // Always show verso on the button
    if (roleBtnImg) roleBtnImg.src = '/static/cards/verso.jpg';
    
    function openPeek() {
      console.log('[LG] openPeek called, role:', state.me?.role);
      if (!state.me?.role) {
        console.log('[LG] No role to show');
        return;
      }
      
      // Set the image to the role
      const roleImg = getRoleImage(state.me.role);
      console.log('[LG] Showing role image:', roleImg);
      rolePeekImg.src = roleImg;
      
      // Show the overlay
      rolePeek.classList.add('open');
      rolePeek.setAttribute('aria-hidden', 'false');
      
      fx?.burst({ kind: 'spark', count: 8 });
    }
    
    function closePeek() {
      console.log('[LG] closePeek called');
      rolePeek.classList.remove('open');
      rolePeek.setAttribute('aria-hidden', 'true');
      rolePeekImg.src = '/static/cards/verso.jpg';
    }
    
    // Desktop: show while holding mouse button
    roleBtn.addEventListener('mousedown', (e) => {
      console.log('[LG] mousedown on roleBtn');
      e.preventDefault();
      openPeek();
    });
    
    document.addEventListener('mouseup', () => {
      console.log('[LG] mouseup');
      closePeek();
    });
    
    // Mobile: show while finger is down
    roleBtn.addEventListener('touchstart', (e) => {
      console.log('[LG] touchstart on roleBtn');
      e.preventDefault();
      openPeek();
    }, { passive: false });
    
    roleBtn.addEventListener('touchend', (e) => {
      console.log('[LG] touchend');
      closePeek();
    });
    
    roleBtn.addEventListener('touchcancel', () => {
      console.log('[LG] touchcancel');
      closePeek();
    });
    
    // Hide when page loses focus
    window.addEventListener('blur', closePeek);
    
    // Tap on overlay to close
    rolePeek.addEventListener('click', closePeek);
    rolePeek.addEventListener('touchend', (e) => {
      e.preventDefault();
      closePeek();
    });
  }
  
  // Modal close
  const modalClose = $('modalClose');
  if (modalClose) {
    modalClose.addEventListener('click', closeModal);
  }
  
  const modal = $('modal');
  if (modal) {
    modal.addEventListener('click', function(e) {
      if (e.target === modal) closeModal();
    });
  }
  
  // Day screen - "go vote" button (optional, server drives this)
  const goVoteBtn = $('goVoteBtn');
  if (goVoteBtn) {
    goVoteBtn.style.display = 'none'; // Hide it - server controls phase transitions
  }
  
  // ============ INITIALIZATION ============
  console.log('[LG] Starting initialization...');
  console.log('[LG] playerId:', config.playerId);
  console.log('[LG] autoJoin:', config.autoJoin);
  console.log('[LG] playerName:', config.playerName);
  
  if (config.playerId) {
    // Already have player ID, reconnect
    console.log('[LG] Reconnecting with existing player ID');
    showScreen('screenWaiting');
    connectWebSocket();
  } else if (config.autoJoin && config.playerName) {
    // Auto-join with name from URL
    console.log('[LG] Auto-joining...');
    joinGame(config.playerName);
  } else {
    // Show join screen
    console.log('[LG] Showing join screen');
    showScreen('screenJoin');
    if (nameInput && config.playerName) {
      nameInput.value = config.playerName;
    }
  }
  
  console.log('[LG] === INITIALIZATION COMPLETE ===');
}

====================================================================================================
PATH: web\static\player.css
---------------------------
/* MVP overrides for Player screen (mobile/9:16 friendly) */
:root{
  /* compatibility with previous JS */
  --green: #22c55e;
  --blue: #3b82f6;
  --red: #ef4444;
}

body{ margin:0; }
.wrap{
  padding: 18px;
  max-width: 560px;
  margin: 0 auto;
}

/* Use the theme's "reveal-card" component for role cards */
.role-reveal{
  width: min(320px, 100%);
  height: min(320px, 92vw);
  margin: 10px auto 0;
}
.roleImg{ width:100%; height:100%; object-fit: cover; display:block; }
.roleBackHint{
  position:absolute;
  left: 12px;
  right: 12px;
  bottom: 12px;
  padding: 10px 12px;
  border-radius: 14px;
  background: rgba(0,0,0,.35);
  border: 1px solid rgba(255,255,255,.14);
  color: rgba(247,242,230,.88);
  font-weight: 800;
  text-align: center;
  backdrop-filter: blur(8px);
}
.roleFront{
  position: absolute;
  inset: 0;
  display: grid;
  grid-template-rows: 1fr auto auto;
}
.roleFront .roleTitle{
  padding: 10px 14px 0;
  font-size: 20px;
  font-weight: 950;
  text-shadow: 0 10px 28px rgba(0,0,0,.55);
}
.roleFront .small{ padding: 0 14px 14px; }

/* inputs */
input, select{
  width: 100%;
  padding: 12px 14px;
  border-radius: 16px;
  background: rgba(0,0,0,.18);
  border: 1px solid rgba(255,255,255,.12);
  color: rgba(247,242,230,.92);
  outline: none;
}
input::placeholder{ color: rgba(247,242,230,.45); }
select{
  appearance: none;
}

/* cards */
.card{ padding: 16px; }

/* buttons */
button{ font: inherit; }
.btn{ cursor:pointer; width: 100%; justify-content: center; }
.btn-row{ display:flex; gap: 10px; }
.btn-row .btn{ width:auto; flex:1; }

#wsDot{
  width: 12px;
  height: 12px;
  border-radius: 999px;
  display:inline-block;
  margin-right: 10px;
  background: rgba(255,255,255,.2);
  box-shadow: 0 0 0 2px rgba(0,0,0,.25) inset;
}

/* tighten spacing */
.card + .card{ margin-top: 14px; }
.pill{ border-radius: 18px; }

.mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace; }
.banner{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
}
.banner .big{ margin: 0; }


/* Card thumbnails in lists */
.miniRole{
  width: 46px;
  height: 46px;
  border-radius: 16px;
  object-fit: cover;
  border: 1px solid rgba(255,255,255,.14);
  box-shadow: 0 14px 28px rgba(0,0,0,.35);
}
.player.is-dead{
  opacity: .75;
  filter: grayscale(.25);
}


/* Player-specific UI */
.section-title{ margin: 0 0 10px; font-size: 14px; letter-spacing:.06em; text-transform: uppercase; color: rgba(247,242,230,.72); }
.row{ display:flex; gap: 10px; align-items:center; flex-wrap: wrap; }
.row > *{ flex:1; min-width: 140px; }
.small{ font-size: 12px; color: rgba(247,242,230,.72); }
.kv{ display:flex; justify-content:space-between; gap:12px; }
.kv b{ font-weight: 700; }

/* Flip card */
.flip{
  width: min(320px, 100%);
  aspect-ratio: 1/1;
  margin: 10px auto 0;
  perspective: 1000px;
}
.flip-inner{
  width:100%; height:100%;
  position: relative;
  transform-style: preserve-3d;
  transition: transform .6s cubic-bezier(.2,.8,.2,1);
}
.flip.is-revealed .flip-inner{ transform: rotateY(180deg); }
.flip-face{
  position:absolute; inset:0;
  backface-visibility: hidden;
  border-radius: 22px;
  overflow:hidden;
  border: 1px solid rgba(255,255,255,.14);
  box-shadow: 0 18px 50px rgba(0,0,0,.55);
}
.flip-face img{ width:100%; height:100%; object-fit: cover; display:block; }
/* Override theme.css - flip-front shows verso (visible by default, no transform) */
.flip-front{ transform: none !important; }
/* flip-back shows role (rotated away by default, visible when flipped) */
.flip-back{ transform: rotateY(180deg); }

/* Lists */
.pillList{ display:flex; flex-wrap: wrap; gap: 8px; }
.pillItem{
  display:flex; align-items:center; gap:10px;
  padding: 8px 10px;
  border-radius: 999px;
  background: rgba(0,0,0,.18);
  border: 1px solid rgba(255,255,255,.12);
}
.pillItem .name{ font-weight: 650; }
.pillItem .tag{ font-size: 12px; color: rgba(247,242,230,.72); }

/* Ensure role image fills the back face grid */
.roleFront .roleImg{ width:100%; height:100%; object-fit:cover; display:block; }
.roleFront{ background: rgba(0,0,0,.02); }

====================================================================================================
PATH: web\static\player.js
--------------------------
(() => {
  const $ = (id) => document.getElementById(id);

  const root = document.querySelector('.app');
  if (window.LG) LG.applyThemeFromQuery(root);

  const { qs, apiOrigin: API_ORIGIN, wsOrigin: WS_ORIGIN } = LG.parseBackendFromQuery();
  $('backendOrigin').textContent = API_ORIGIN;

  // Bot mode from URL (?bot=1)
  const BOT = qs.get('bot') === '1';
  $('botPill').textContent = BOT ? 'OUI' : 'NON';

  // FX
  const fx = window.LGFX?.init($('fxCanvas'), { mode: 'night' });

  // Optional sound FX (enable with ?sound=1)
  const sfx = window.LGSFX?.fromQuery?.() || null;

  // --- WS status dot
  const wsDot = $('wsDot');
  const setDot = (ok) => {
    wsDot.style.background = ok ? 'rgba(34,197,94,.95)' : 'rgba(239,68,68,.95)';
    wsDot.style.boxShadow = ok
      ? '0 0 0 2px rgba(0,0,0,.25) inset, 0 0 18px rgba(34,197,94,.35)'
      : '0 0 0 2px rgba(0,0,0,.25) inset, 0 0 18px rgba(239,68,68,.35)';
  };
  setDot(false);

  // --- Modal helpers
  const modal = $('modal');
  const modalTitle = $('modalTitle');
  const modalBody = $('modalBody');
  const closeModal = () => { modal.style.display = 'none'; };
  const openModal = (title, html) => {
    modalTitle.textContent = title;
    modalBody.innerHTML = html;
    modal.style.display = 'block';
    fx?.burst({ kind: 'magic', count: 22 });
  };
  $('modalClose').addEventListener('click', closeModal);
  $('modalOk').addEventListener('click', closeModal);
  modal.addEventListener('click', (e) => {
    if (e.target === modal) closeModal();
  });

  // --- Log
  const logEl = $('log');
  function appendLog(line){
    logEl.textContent += line + '\n';
    logEl.scrollTop = logEl.scrollHeight;
  }

  // --- Role card
  const roleCardWrap = $('roleCardWrap');
  const roleCard = $('roleCard');
  const spot = $('spot');
  const roleBackImg = $('roleBackImg');
  const roleFrontImg = $('roleFrontImg');
  const roleTitle = $('roleTitle');
  const flipBtn = $('flipBtn');

  function setRoleCard(roleKey){
    // Back: verso
    LG.setImgWithFallback(roleBackImg, LG.VERSO.primary, LG.VERSO.fallback);

    // Front: role image
    const files = LG.cardForRole(roleKey);
    LG.setImgWithFallback(roleFrontImg, files.primary, files.fallback);

    roleTitle.textContent = LG.roleLabel(roleKey);
  }

  function setCardFlipped(on){
    roleCard.classList.toggle('is-revealed', !!on);
    spot.classList.toggle('is-on', !!on);
    if (on) fx?.burst({ kind: 'spark', count: 16 });
  }

  roleCard.addEventListener('click', () => {
    sfx?.click?.();
    setCardFlipped(!roleCard.classList.contains('is-revealed'));
  });
  roleCard.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      sfx?.click?.();
      setCardFlipped(!roleCard.classList.contains('is-revealed'));
    }
  });
  flipBtn.addEventListener('click', () => {
    sfx?.click?.();
    setCardFlipped(!roleCard.classList.contains('is-revealed'));
  });

  // --- Join
  const joinCard = $('joinCard');
  const nameInput = $('nameInput');
  const joinBtn = $('joinBtn');

  let playerId = qs.get('player_id') || '';
  let playerName = qs.get('name') || '';
  const AUTOJOIN = qs.get('autojoin') === '1';

  $('playerName').textContent=playerName||'—';

  function showJoinIfNeeded(){
    if (playerId) {
      joinCard.style.display = 'none';
      return;
    }
    joinCard.style.display = 'block';
    nameInput.value = playerName || '';
    nameInput.focus();
  }

  async function join(name){
    const r = await fetch(`${API_ORIGIN}/api/join`, {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ name })
    });
    const j = await r.json();
    if (!j.ok) throw new Error(j.error || 'join failed');
    playerId = j.player_id;
    playerName = name;

    // Update URL so refresh keeps the session
    const next = new URL(location.href);
    next.searchParams.set('player_id', playerId);
    next.searchParams.set('name', playerName);
    history.replaceState({}, '', next.toString());
    $('playerIdPill').textContent = `ID: ${playerId}`;
    $('playerName').textContent = playerName;
    joinCard.style.display = 'none';
    fx?.burst({ kind:'magic', count: 28 });
  }

  joinBtn.addEventListener('click', async () => {
    try{
      const n = (nameInput.value || '').trim();
      if (!n) return alert('Veuillez entrer un nom.');
      sfx?.confirm?.();
      await join(n);
      connect();
    }catch(e){
      alert(String(e));
    }
  });

  // If name in query and autojoin, join immediately.
  (async () => {
    showJoinIfNeeded();
    if (!playerId && AUTOJOIN && playerName){
      try{
        await join(playerName);
      }catch(e){
        console.warn(e);
      }
    }
    if (playerId) {
      $('playerIdPill').textContent = `ID: ${playerId}`;
      roleCardWrap.style.display = 'block';
      connect();
    }
  })();

  // --- Action UI
  const actionCard = $('actionCard');
  const actionUI = $('actionUI');
  const actionHint = $('actionHint');
  const submitActionBtn = $('submitActionBtn');

  const voteCard = $('voteCard');
  const voteSelect = $('voteSelect');
  const voteBtn = $('voteBtn');
  const voteStatus = $('voteStatus');

  let currentPhase = '—';
  let lastPrivate = null;


  // --- BOT helpers (auto vote + auto actions)
  const bot = {
    voteKey: null,
    acted: new Set(),
    rand(min, max){ return Math.floor(min + Math.random() * (max - min + 1)); },
    pick(arr){ return arr && arr.length ? arr[Math.floor(Math.random() * arr.length)] : null; },
    sleep(ms){ return new Promise(res => setTimeout(res, ms)); },
  };

  async function botMaybeVote(state){
    if (!BOT) return;
    if (!state || state.phase !== 'VOTE') return;
    if (!state.me || !state.me.alive) return;

    const key = state.timers?.phase_ends_at || null;
    if (!key || bot.voteKey === key) return;
    bot.voteKey = key;

    const targets = (state.alive || []).filter(p => p.id !== playerId);
    const t = bot.pick(targets);
    if (!t) return;

    await bot.sleep(bot.rand(450, 1200));
    try{
      const r = await fetch(`${API_ORIGIN}/api/vote`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ voter_id: playerId, target_id: t.id })
      });
      const j = await r.json();
      if (j.ok) {
        voteStatus.textContent = 'Vote envoyé (bot).';
        fx?.burst({ kind: 'spark', count: 14 });
      }
    }catch{}
  }

  async function botMaybeAction(step, deadline){
    if (!BOT) return;
    if (!lastPrivate || !lastPrivate.me || !lastPrivate.me.alive) return;
    if (lastPrivate.phase !== 'NIGHT') return;

    const key = `${step}:${deadline || ''}`;
    if (bot.acted.has(key)) return;
    bot.acted.add(key);

    const targets = (lastPrivate.alive || []).filter(p => p.id !== playerId);
    const me = lastPrivate.me;

    let payload = null;
    if (step === 'WOLVES' && me.role === 'werewolf') {
      const t = bot.pick(targets); if (!t) return;
      payload = { step: 'WOLVES', data: { target: t.id } };
    } else if (step === 'SEER' && me.role === 'seer') {
      const t = bot.pick(targets); if (!t) return;
      payload = { step: 'SEER', data: { target: t.id } };
    } else if (step === 'WITCH' && me.role === 'witch') {
      const canHeal = !me.witch_heal_used;
      const canPoison = !me.witch_poison_used;
      const heal = canHeal ? (Math.random() < 0.5) : false;
      const poisonTarget = (canPoison && Math.random() < 0.35) ? (bot.pick(targets)?.id || null) : null;
      payload = { step: 'WITCH', data: { heal, poison_target: poisonTarget } };
    } else if (step === 'CUPID' && me.role === 'cupid') {
      if ((lastPrivate.alive || []).length < 2) return;
      const pool = (lastPrivate.alive || []).map(p => p.id);
      const a = bot.pick(pool);
      const b = bot.pick(pool.filter(x => x !== a));
      if (!a || !b) return;
      payload = { step: 'CUPID', data: { targets: [a, b] } };
    } else {
      return;
    }

    await bot.sleep(bot.rand(500, 1400));
    try{
      const r = await fetch(`${API_ORIGIN}/api/action`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ player_id: playerId, ...payload })
      });
      const j = await r.json();
      if (j.ok) fx?.burst({ kind: 'magic', count: 16 });
    }catch{}
  }

  function setNightMode(isNight){
    root.classList.toggle('is-night', isNight);
    fx?.setMode(isNight ? 'night' : 'day');
  }

  function applyPublic(state){
    if (!state) return;
    const phase = state.phase || '—';
    if (phase !== currentPhase){
      currentPhase = phase;
      fx?.burst({ kind: phase === 'NIGHT' ? 'magic' : 'ember', count: 18 });
    }
    $('phase').textContent = phase;

    const secs = state.timers?.seconds_left;
    $('timer').textContent = (secs === null || secs === undefined) ? '—' : `${secs}s`;
    setNightMode(phase === 'NIGHT');

    if (phase !== 'NIGHT') { window.__pendingStep = null; window.__pendingDeadline = null; window.__witchCtx = null; }

    renderAliveDead(state.alive || [], state.dead || []);
  }

  function applyPrivate(state){
    if (!state || !state.me) return;
    lastPrivate = state;
    const me = state.me;

    // Server tells each player if they currently have a night action pending
    if (state.pending_step) {
      window.__pendingStep = state.pending_step;
      window.__pendingDeadline = state.pending_deadline || null;
    } else {
      window.__pendingStep = null;
      window.__pendingDeadline = null;
    }
    if (state.witch_ctx) { window.__witchCtx = state.witch_ctx; }

    $('playerName').textContent = me.name || '—';
    const t = me.name || 'Joueur';
    const ht = $('headerTitle');
    if (ht) ht.textContent = t;
    document.title = `Loup-Garou — ${t}`;

    $('aliveText').textContent = me.alive ? 'Vivant' : 'Mort';
    const roleKey = me.role || null;
    $('roleText').textContent = me.role_fr || LG.roleLabel(roleKey);

    roleCardWrap.style.display = 'block';
    setRoleCard(roleKey);

    // Default: show back unless user already flipped
    if (!roleCard.classList.contains('is-revealed')) setCardFlipped(false);

    // Lover reveal (only once)
    if (me.lover_id && state.lover_name && !window.__loverShown){
      window.__loverShown = true;
      openModal('Le Cupidon — Ton amoureux(se)', `
        <div class="reveal-hero">
          <div class="muted">Ton amoureux(se) est :</div>
          <div style="font-size:22px;font-weight:950;margin-top:8px;">${LG.escapeHtml(state.lover_name)}</div>
          <div class="hint inline">Si l’un meurt, l’autre meurt aussi (règle classique).</div>
        </div>
      `);
    }

    // Action steps
    updateActionUI(state);
    updateVoteUI(state);
    botMaybeVote(state);
    botMaybeAction(window.__pendingStep, window.__pendingDeadline);
  }

  function renderAliveDead(alive, dead){
    const aliveEl = $('aliveList');
    const deadEl = $('deadList');

    aliveEl.innerHTML = '';
    if (!alive.length) aliveEl.innerHTML = '<div class="muted">—</div>';
    for (const p of alive){
      const row = document.createElement('div');
      row.className = 'pillItem player';
      row.innerHTML = `
        <img class="miniRole" alt="card" src="${LG.CARD_BASE}${LG.VERSO.fallback}" />
        <div>
          <div class="name">${LG.escapeHtml(p.name)}</div>
          <div class="tag mono">${LG.escapeHtml(p.id)}</div>
        </div>
      `;
      // Load nicer verso (jpg if present)
      const img = row.querySelector('img');
      LG.setImgWithFallback(img, LG.VERSO.primary, LG.VERSO.fallback);
      aliveEl.appendChild(row);
    }

    deadEl.innerHTML = '';
    if (!dead.length) deadEl.innerHTML = '<div class="muted">—</div>';
    for (const p of dead){
      const row = document.createElement('div');
      row.className = 'pillItem player is-dead';
      const files = LG.cardForRole(p.role);
      const roleLabel = p.role_fr || LG.roleLabel(p.role);
      row.innerHTML = `
        <img class="miniRole" alt="role" src="${LG.CARD_BASE}${files.fallback}" />
        <div>
          <div class="name">${LG.escapeHtml(p.name)}</div>
          <div class="tag">${LG.escapeHtml(roleLabel)}</div>
        </div>
      `;
      const img = row.querySelector('img');
      LG.setImgWithFallback(img, files.primary, files.fallback);
      deadEl.appendChild(row);
    }
  }

  function updateVoteUI(state){
    const phase = state.phase;
    if (phase !== 'VOTE'){
      voteCard.style.display = 'none';
      return;
    }
    voteCard.style.display = 'block';
    const alive = (state.alive || []).filter(p => p.id !== playerId);
    voteSelect.innerHTML = '';
    for (const p of alive){
      const opt = document.createElement('option');
      opt.value = p.id;
      opt.textContent = p.name;
      voteSelect.appendChild(opt);
    }
    if (!alive.length){
      const opt = document.createElement('option');
      opt.value = '';
      opt.textContent = 'Aucune cible';
      voteSelect.appendChild(opt);
    }
  }

  voteBtn.addEventListener('click', async () => {
    if (!playerId) return;
    const target = voteSelect.value;
    if (!target) return;
    try{
      sfx?.click?.();
      voteStatus.textContent = 'Vote en cours…';
      const r = await fetch(`${API_ORIGIN}/api/vote`, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ voter_id: playerId, target_id: target })
      });
      const j = await r.json();
      if (!j.ok) throw new Error(j.error || 'vote failed');
      voteStatus.textContent = 'Vote envoyé.';
      sfx?.confirm?.();
      fx?.burst({ kind:'spark', count: 14 });
    }catch(e){
      voteStatus.textContent = 'Échec du vote.';
      alert(String(e));
    }
  });

  // --- Role actions UI
  let actionSelection = null;

  function updateActionUI(state){
    const me = state?.me;
    const phase = state?.phase;

    actionSelection = null;
    submitActionBtn.style.display = 'none';
    actionUI.innerHTML = '';
    actionCard.style.display = 'none';

    if (!me || !me.alive) return;
    if (phase !== 'NIGHT') return;

    // Only show UI when server is actively requesting an action.
    const pendingStep = window.__pendingStep || null; // e.g. 'WOLVES', 'SEER', 'WITCH', 'CUPID'
    if (!pendingStep) return;

    const aliveTargets = (state.alive || []).filter(p => p.id !== playerId);
    // ---- WOLVES (propositions + majorité à la fin)
    if (pendingStep === 'WOLVES' && me.role === 'werewolf'){
      actionCard.style.display = 'block';
      // NOTE: use double quotes to avoid breaking JS parsing with apostrophes.
      actionHint.textContent = "Les Loups-Garous proposent une victime. Essayez d'atteindre l'unanimité ; sinon, la majorité l'emporte à la fin du temps.";

      const wolvesTeam = (state.wolves_team || []).map(w => w.id);
      const aliveTargets = (state.alive || []).filter(p => !wolvesTeam.includes(p.id));

      const sel = document.createElement('select');
      for (const p of aliveTargets){
        const opt = document.createElement('option');
        opt.value = p.id;
        opt.textContent = p.name;
        sel.appendChild(opt);
      }
      if (!aliveTargets.length){
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = 'Aucune cible';
        sel.appendChild(opt);
      }

      // Keep last choice across state refreshes
      if (window.__wolfChoice && [...sel.options].some(o => o.value === window.__wolfChoice)){
        sel.value = window.__wolfChoice;
      }
      sel.addEventListener('change', () => { window.__wolfChoice = sel.value; });

      const status = document.createElement('div');
      status.className = 'small';
      status.style.marginTop = '10px';

      const suggestions = document.createElement('div');
      suggestions.className = 'pillList';
      suggestions.style.marginTop = '10px';

      function renderSuggestions(){
        const votes = state.wolves_votes || {};
        suggestions.innerHTML = '';

        // per-wolf line
        const team = state.wolves_team || [];
        const byId = new Map((state.alive || []).map(p => [p.id, p.name]));
        const tally = {};
        let filled = 0;
        for (const w of team){
          const t = votes[w.id] || null;
          if (t) { tally[t] = (tally[t]||0)+1; filled += 1; }
          const pill = document.createElement('div');
          pill.className = 'pillItem';
          pill.innerHTML = `<div><div class="name">${LG.escapeHtml(w.name)}</div><div class="tag">${t ? LG.escapeHtml(byId.get(t) || t) : '—'}</div></div>`;
          suggestions.appendChild(pill);
        }

        const total = team.length || 0;
        const targets = Object.keys(tally);
        const unanimous = total > 0 && filled === total && targets.length === 1;
        if (unanimous){
          status.textContent = `Unanimité : ${byId.get(targets[0]) || targets[0]} ✓`;
        } else if (targets.length){
          const maxv = Math.max(...Object.values(tally));
          const leaders = targets.filter(t => tally[t] === maxv);
          if (leaders.length === 1){
            status.textContent = `Tendance : ${byId.get(leaders[0]) || leaders[0]} (${maxv}/${total})`;
          } else {
            status.textContent = `Égalité (${maxv}/${total}) — continuez à vous coordonner.`;
          }
        } else {
          status.textContent = 'En attente des propositions des loups…';
        }
      }
      renderSuggestions();

      actionUI.appendChild(sel);
      actionUI.appendChild(status);
      actionUI.appendChild(suggestions);

      actionSelection = () => ({ step: 'WOLVES', data: { target: sel.value } });
      submitActionBtn.textContent = 'Proposer';
      submitActionBtn.style.display = 'block';
      return;
    }

    // ---- SEER
    if (pendingStep === 'SEER' && me.role === 'seer'){
      actionCard.style.display = 'block';
      actionHint.textContent = 'La Voyante révèle le rôle d’un joueur.';

      const sel = document.createElement('select');
      for (const p of aliveTargets){
        const opt = document.createElement('option');
        opt.value = p.id;
        opt.textContent = p.name;
        sel.appendChild(opt);
      }
      actionUI.appendChild(sel);
      actionSelection = () => ({ step: 'SEER', data: { target: sel.value } });
      submitActionBtn.style.display = 'block';
      return;
    }

    // ---- WITCH
    if (pendingStep === 'WITCH' && me.role === 'witch'){
      actionCard.style.display = 'block';
      const canHeal = !me.witch_heal_used;
      const canPoison = !me.witch_poison_used;

      const victimName = window.__witchCtx?.victim_name || window.__witchCtx?.wolves_victim_name || null;
      const victimLine = victimName ? `Victime (ciblée par les Loups) : ${victimName}.` : 'Victime (ciblée par les Loups) : inconnue.';
      actionHint.textContent = `La Sorcière agit. ${victimLine}`;

      const row = document.createElement('div');
      row.className = 'row';

      const healBtn = document.createElement('button');
      healBtn.className = 'btn btn-secondary';
      healBtn.textContent = canHeal ? 'Sauver la victime (potion de vie)' : 'Potion de vie utilisée';
      healBtn.disabled = !canHeal;

      const poisonSel = document.createElement('select');
      poisonSel.disabled = !canPoison;
      const opt0 = document.createElement('option');
      opt0.value = '';
      opt0.textContent = 'Empoisonner (optionnel)';
      poisonSel.appendChild(opt0);
      for (const p of aliveTargets){
        const opt = document.createElement('option');
        opt.value = p.id;
        opt.textContent = p.name;
        poisonSel.appendChild(opt);
      }

      row.appendChild(healBtn);
      row.appendChild(poisonSel);
      actionUI.appendChild(row);

      let heal = false;
      healBtn.addEventListener('click', () => {
        heal = !heal;
        healBtn.classList.toggle('is-on', heal);
        fx?.burst({ kind:'magic', count: 14 });
      });

      actionSelection = () => ({
        step: 'WITCH',
        data: {
          heal: canHeal ? !!heal : false,
          poison_target: canPoison ? (poisonSel.value || null) : null,
        }
      });

      submitActionBtn.style.display = (canHeal || canPoison) ? 'block' : 'none';
      return;
    }

    // ---- CUPID
    if (pendingStep === 'CUPID' && me.role === 'cupid'){
      actionCard.style.display = 'block';
      actionHint.textContent = 'Le Cupidon désigne deux amoureux. Ils ne peuvent pas être la même personne.';

      // Preserve selections across state refreshes
      const existingSel1 = actionUI.querySelector('#cupidSel1');
      const existingSel2 = actionUI.querySelector('#cupidSel2');
      const prevVal1 = existingSel1?.value || window.__cupidChoice1 || '';
      const prevVal2 = existingSel2?.value || window.__cupidChoice2 || '';

      // Only rebuild if not already present
      if (!existingSel1 || !existingSel2) {
        const alivePlayers = (state.alive || []);

        const sel1 = document.createElement('select');
        sel1.id = 'cupidSel1';
        const sel2 = document.createElement('select');
        sel2.id = 'cupidSel2';

        // Add placeholder option
        const ph1 = document.createElement('option');
        ph1.value = ''; ph1.textContent = '— Premier amoureux —';
        sel1.appendChild(ph1);
        const ph2 = document.createElement('option');
        ph2.value = ''; ph2.textContent = '— Deuxième amoureux —';
        sel2.appendChild(ph2);

        for (const p of alivePlayers){
          const o1 = document.createElement('option');
          o1.value = p.id; o1.textContent = p.name;
          const o2 = document.createElement('option');
          o2.value = p.id; o2.textContent = p.name;
          sel1.appendChild(o1);
          sel2.appendChild(o2);
        }

        // Restore previous selections
        if (prevVal1 && [...sel1.options].some(o => o.value === prevVal1)) {
          sel1.value = prevVal1;
        }
        if (prevVal2 && [...sel2.options].some(o => o.value === prevVal2)) {
          sel2.value = prevVal2;
        }

        // Function to update disabled state
        const updateDisabled = () => {
          const v1 = sel1.value;
          const v2 = sel2.value;
          // Disable option in sel2 if it matches sel1
          for (const opt of sel2.options) {
            opt.disabled = (opt.value && opt.value === v1);
          }
          // Disable option in sel1 if it matches sel2
          for (const opt of sel1.options) {
            opt.disabled = (opt.value && opt.value === v2);
          }
          // Save choices
          window.__cupidChoice1 = v1;
          window.__cupidChoice2 = v2;
        };

        sel1.addEventListener('change', updateDisabled);
        sel2.addEventListener('change', updateDisabled);

        // Prevent dropdown from closing on mousedown (stop event bubbling)
        sel1.addEventListener('mousedown', (e) => e.stopPropagation());
        sel2.addEventListener('mousedown', (e) => e.stopPropagation());

        updateDisabled();

        const row = document.createElement('div');
        row.className = 'row';
        row.appendChild(sel1);
        row.appendChild(sel2);

        // Error message container
        const errorDiv = document.createElement('div');
        errorDiv.id = 'cupidError';
        errorDiv.className = 'small';
        errorDiv.style.color = 'var(--red, #ef4444)';
        errorDiv.style.marginTop = '8px';

        actionUI.innerHTML = '';
        actionUI.appendChild(row);
        actionUI.appendChild(errorDiv);
      }

      actionSelection = () => {
        const s1 = actionUI.querySelector('#cupidSel1');
        const s2 = actionUI.querySelector('#cupidSel2');
        const errDiv = actionUI.querySelector('#cupidError');
        if (!s1 || !s2) return null;
        
        if (!s1.value || !s2.value) {
          if (errDiv) errDiv.textContent = 'Veuillez sélectionner deux joueurs.';
          return null;
        }
        if (s1.value === s2.value) {
          if (errDiv) errDiv.textContent = 'Les deux amoureux doivent être différents !';
          return null;
        }
        if (errDiv) errDiv.textContent = '';
        return { step: 'CUPID', data: { targets: [s1.value, s2.value] } };
      };
      submitActionBtn.style.display = 'block';
      return;
    }
  }

  submitActionBtn.addEventListener('click', async () => {
    if (!playerId || !actionSelection) return;
    const payload = actionSelection();
    if (!payload) return;
    try{
      sfx?.click?.();
      const r = await fetch(`${API_ORIGIN}/api/action`, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ player_id: playerId, ...payload })
      });
      const j = await r.json();
      if (!j.ok) throw new Error(j.error || 'action failed');
      sfx?.confirm?.();
      fx?.burst({ kind:'magic', count: 22 });
      submitActionBtn.textContent = 'Validé ✓';
      setTimeout(() => (submitActionBtn.textContent = 'Valider'), 900);
    }catch(e){
      alert(String(e));
    }
  });

  // --- WebSocket
  let ws;
  function connect(){
    if (!playerId){ showJoinIfNeeded(); return; }
    const url = `${WS_ORIGIN}/ws?client=player&player_id=${encodeURIComponent(playerId)}`;
    ws = new WebSocket(url);

    ws.onopen = () => { setDot(true); fx?.burst({ kind:'magic', count: 18 }); };
    ws.onclose = () => { setDot(false); setTimeout(connect, 700); };
    ws.onerror = () => { setDot(false); };

    ws.onmessage = (ev) => {
      let msg;
      try{ msg = JSON.parse(ev.data); }catch{ return; }

      if (msg.type === 'PUBLIC_STATE'){
        applyPublic(msg.data);
      } else if (msg.type === 'PRIVATE_STATE'){
        applyPrivate(msg.data);
      } else if (msg.type === 'NARRATOR_LINE'){
        appendLog(msg.line);
      } else if (msg.type === 'SEER_RESULT'){
        const targetName = msg.target_name || '—';
        const roleKey = msg.role || null;
        const roleFr = msg.role_fr || LG.roleLabel(roleKey);
        const files = LG.cardForRole(roleKey);
        openModal('La Voyante — Révélation', `
          <div class="reveal-hero">
            <div class="muted">${LG.escapeHtml(targetName)} est :</div>
            <div style="font-size:22px;font-weight:950;margin-top:8px;">${LG.escapeHtml(roleFr)}</div>
            <div style="margin-top:12px;display:grid;place-items:center;">
              <div class="reveal-card is-flipped" style="width:min(320px,92%);height:min(320px,92vw);">
                <div class="reveal-face"><img class="roleImg" src="${LG.CARD_BASE}${LG.VERSO.fallback}" alt="verso" /></div>
                <div class="reveal-face face-front">
                  <img id="seerRoleImg" class="roleImg" alt="role" />
                </div>
              </div>
            </div>
          </div>
        `);
        // set image after insertion
        setTimeout(() => {
          const img = document.getElementById('seerRoleImg');
          if (img) LG.setImgWithFallback(img, files.primary, files.fallback);
        }, 0);
      } else if (msg.type === 'ACTION_REQUEST') {
        window.__pendingStep = msg.step || null;
        window.__pendingDeadline = msg.deadline || null;
        // force refresh of action UI if we already have private state
        if (lastPrivate) updateActionUI(lastPrivate);
        botMaybeAction(window.__pendingStep, window.__pendingDeadline);
      } else if (msg.type === 'WITCH_CONTEXT') {
        window.__witchCtx = { wolves_victim_id: msg.wolves_victim_id, wolves_victim_name: msg.wolves_victim_name };
        if (lastPrivate) updateActionUI(lastPrivate);
            } else if (msg.type === 'GAME_OVER'){
        const w = msg.winner_fr || msg.winner || '—';
        openModal('Fin de partie', `<div class="reveal-hero"><div style="font-size:22px;font-weight:950;">Victoire : ${LG.escapeHtml(w)}</div></div>`);
      } else if (msg.type === 'RESET'){
        logEl.textContent = '';
        voteStatus.textContent = '';
      }
    };
  }
})();

====================================================================================================
PATH: web\static\theme.css
--------------------------
/* Loup Garou — Style Playground
   Pure HTML/CSS/JS, offline. */

:root{
  /* Medieval palette */
  --bg0:#140b06;
  --bg1:#241508;
  --wood1:#2a160a;
  --wood2:#1b0f07;

  --paper:#f1e5c8;
  --paper2:#e9d8b3;
  --ink:#1b1a17;

  --panel: rgba(0,0,0,.22);
  --panel2: rgba(0,0,0,.28);
  --stroke: rgba(255,255,255,.12);

  --text:#f7f2e6;
  --muted: rgba(247,242,230,.72);

  --gold:#d6b15a;
  --accent:#d6b15a;   /* gold */
  --accent2:#b45309;  /* ember */
  --danger:#ef4444;
  --warn:#f59e0b;

  --shadow: 0 18px 60px rgba(0,0,0,.55);
  --radius: 18px;
  --radius2: 24px;

  --glow: 0 0 36px rgba(214,177,90,.22);
  --glow2: 0 0 50px rgba(180,83,9,.22);

  --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
  --serif: ui-serif, Georgia, "Times New Roman", Times, serif;
  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}

*{ box-sizing: border-box; }
html,body {

  margin:0;
  font-family: var(--font);
  color: var(--text);

  /* wood table + torch light */
  background:
    radial-gradient(1200px 700px at 30% 18%, rgba(214,177,90,.18), transparent 62%),
    radial-gradient(900px 520px at 70% 28%, rgba(180,83,9,.14), transparent 60%),
    radial-gradient(1200px 900px at 50% 120%, rgba(0,0,0,.55), transparent 55%),
    repeating-linear-gradient(90deg, rgba(255,255,255,.02) 0 3px, rgba(0,0,0,.03) 3px 6px),
    linear-gradient(160deg, var(--wood1), var(--wood2));

  

  overflow: auto;
  overscroll-behavior: contain;
  -webkit-overflow-scrolling: touch;
}

.app{ display:flex; min-height:100vh; height:auto; position:relative; }
#fxCanvas{
  position:absolute; inset:0; width:100%; height:100%;
  pointer-events:none;
  mix-blend-mode: screen;
  opacity:.85;
}

.sidebar{
  width: 320px;
  padding: 16px 14px;
  border-right: 1px solid var(--stroke);
  background: linear-gradient(180deg, rgba(0,0,0,.55), rgba(0,0,0,.28));
  backdrop-filter: blur(14px);
}

.brand{
  display:flex; align-items:center; gap:12px;
  padding: 10px 10px 14px;
}
.logo{
  width: 44px; height:44px;
  border-radius: 14px;
  display:grid; place-items:center;
  background: linear-gradient(135deg, rgba(167,139,250,.25), rgba(34,197,94,.16));
  border: 1px solid var(--stroke);
  box-shadow: var(--shadow), var(--glow);
  font-weight: 800;
  letter-spacing: .6px;
}
.title{ font-weight: 800; font-size: 18px; }
.subtitle{ color: var(--muted); font-size: 12px; margin-top: 2px; }

.panel{
  margin-top: 8px;
  background: var(--panel);
  border: 1px solid var(--stroke);
  border-radius: var(--radius2);
  padding: 14px;
  box-shadow: var(--shadow);
  position:relative;
  overflow:hidden;
}
.panel:before{
  content:"";
  position:absolute; inset:-2px;
  background: radial-gradient(500px 220px at 0% 0%, rgba(255,255,255,.06), transparent 60%);
  pointer-events:none;
}

.label{
  display:block;
  font-size: 12px;
  color: var(--muted);
  margin: 10px 2px 8px;
  letter-spacing: .2px;
}

.select{
  width:100%;
  padding: 10px 12px;
  border-radius: 14px;
  border: 1px solid var(--stroke);
  background: rgba(0,0,0,.25);
  color: var(--text);
  outline:none;
}

.row{ display:flex; gap:10px; align-items:center; }
.row-gap{ margin-top: 12px; flex-wrap:wrap; }

.btn{
  display:inline-flex;
  align-items:center;
  gap:8px;
  padding: 10px 12px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.14);
  background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
  color: var(--text);
  cursor:pointer;
  box-shadow: 0 14px 40px rgba(0,0,0,.40);
  transition: transform .12s ease, filter .2s ease, background .2s ease;
  user-select:none;
}
.btn:hover{ filter: brightness(1.08); }
.btn:active{ transform: scale(.98); }

.btn-secondary{
  background: rgba(0,0,0,.22);
}
.btn-ghost{
  background: rgba(0,0,0,.08);
  border-color: rgba(255,255,255,.10);
  box-shadow:none;
}
.ico{ font-size: 16px; }

.divider{
  height: 1px;
  background: rgba(255,255,255,.10);
  margin: 14px 0 8px;
}

.checks{ display:grid; gap:8px; }
.check{ font-size: 13px; color: var(--muted); }
.check input{ transform: translateY(1px); }

.seg{
  display:flex;
  border: 1px solid rgba(255,255,255,.12);
  border-radius: 16px;
  overflow:hidden;
  background: rgba(0,0,0,.20);
}
.segbtn{
  flex:1;
  padding: 9px 10px;
  border:0;
  background: transparent;
  color: var(--muted);
  cursor:pointer;
  font-weight: 700;
  letter-spacing: .2px;
}
.segbtn.is-on{
  color: var(--text);
  background: linear-gradient(180deg, rgba(167,139,250,.22), rgba(255,255,255,.02));
}

.hint{
  margin-top: 14px;
  padding: 10px 12px;
  border-radius: 16px;
  border: 1px dashed rgba(255,255,255,.18);
  color: var(--muted);
  font-size: 12px;
  line-height: 1.35;
}
.hint.inline{
  margin-top: 12px;
}

.footer{
  margin-top: 12px;
  padding: 8px 10px;
  color: rgba(233,237,247,.55);
}

.main{ flex:1; display:flex; flex-direction:column; position:relative; }
.topbar{
  height: 64px;
  padding: 14px 18px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  border-bottom: 1px solid var(--stroke);
  background: linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.10));
  backdrop-filter: blur(14px);
}
.crumb{ display:flex; align-items:center; gap:10px; color: var(--muted); font-size: 13px; }
.badge{
  padding: 4px 8px;
  border-radius: 999px;
  font-size: 11px;
  color: rgba(255,255,255,.85);
  border: 1px solid rgba(255,255,255,.14);
  background: rgba(214,177,90,.18);
}
.dot{ width: 4px; height:4px; border-radius:999px; background: rgba(255,255,255,.3); }
.actions{ display:flex; gap:10px; align-items:center; }

.stage{
  flex:1;
  position:relative;
  padding: 18px;
  overflow:auto;
}
.scene{ display:none; animation: sceneIn .35s ease both; }
.scene.is-active{ display:block; }

@keyframes sceneIn{
  from{ opacity:0; transform: translateY(8px); filter: blur(6px); }
  to{ opacity:1; transform: translateY(0); filter: blur(0); }
}

.grid2{ display:grid; gap: 16px; grid-template-columns: 1fr 1fr; }
@media (max-width: 980px){
  body{ overflow:auto; }
  .app{ flex-direction:column; overflow:auto; }
  .sidebar{ width:100%; border-right:0; border-bottom:1px solid var(--stroke); }
  .grid2{ grid-template-columns: 1fr; }
  #fxCanvas{ position:fixed; }
}

.card{
  background: var(--panel);
  border: 1px solid var(--stroke);
  border-radius: var(--radius2);
  padding: 16px;
  box-shadow: var(--shadow);
  position:relative;
  overflow:hidden;
}
.card.big{ padding: 18px; }
.card:before{
  content:"";
  position:absolute; inset:-1px;
  background: radial-gradient(600px 220px at 20% 0%, rgba(255,255,255,.08), transparent 58%);
  pointer-events:none;
}
.card:after{
  content:"";
  position:absolute; inset:-2px;
  background: radial-gradient(420px 220px at 100% 40%, rgba(167,139,250,.06), transparent 60%);
  pointer-events:none;
}

.card-h{
  display:flex;
  justify-content:space-between;
  align-items:flex-start;
  gap:12px;
  margin-bottom: 14px;
}
.kicker{
  color: var(--muted);
  font-size: 12px;
  letter-spacing: .25px;
  text-transform: uppercase;
}
.h1{ font-size: 20px; font-weight: 900; margin-top: 2px; }
.h2{ font-size: 18px; font-weight: 900; margin: 0; }
.muted{ color: var(--muted); }
.smallcap{ font-size: 12px; color: var(--muted); letter-spacing:.2px; }
.accent{ color: var(--accent); }

.pill{
  display:inline-flex;
  align-items:center;
  gap:8px;
  padding: 7px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.14);
  background: rgba(0,0,0,.18);
  color: rgba(255,255,255,.86);
  font-size: 12px;
}
.pill.soft{ background: rgba(255,255,255,.06); }
.pill.danger{ background: rgba(239,68,68,.12); border-color: rgba(239,68,68,.22); }
.pill.success{ background: rgba(34,197,94,.12); border-color: rgba(34,197,94,.22); }

.pulse{
  width: 8px; height:8px; border-radius: 999px;
  background: rgba(34,197,94,.85);
  box-shadow: 0 0 18px rgba(34,197,94,.55);
  animation: pulse 1.25s ease-in-out infinite;
}
@keyframes pulse{
  0%,100%{ transform:scale(.9); opacity:.7; }
  50%{ transform:scale(1.25); opacity:1; }
}

/* Players */
.player-list{
  display:grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 10px;
}
.player{
  display:flex;
  gap:10px;
  align-items:center;
  padding: 10px 10px;
  border-radius: 16px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.18);
  position:relative;
  overflow:hidden;
}
.player:before{
  content:"";
  position:absolute; inset:-2px;
  background: radial-gradient(280px 140px at 10% 0%, rgba(255,255,255,.06), transparent 70%);
  pointer-events:none;
}
.avatar{
  width: 36px; height:36px; border-radius: 14px;
  display:grid; place-items:center;
  font-weight: 900;
  color: rgba(0,0,0,.78);
  box-shadow: 0 14px 28px rgba(0,0,0,.35);
}
.p-name{ font-weight: 800; font-size: 13px; }
.p-sub{ color: var(--muted); font-size: 12px; margin-top: 2px; }

/* Role cards */
.card-grid{
  display:grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 10px;
}
@media (max-width: 980px){ .card-grid{ grid-template-columns: repeat(2, 1fr);} }


/* Role cards (official images) */
.role-card{
  text-align:left;
  border-radius: 18px;
  border: 1px solid rgba(0,0,0,.35);
  background: rgba(0,0,0,.14);
  padding: 10px;
  cursor:pointer;
  color: var(--text);
  position:relative;
  overflow:hidden;
  transition: transform .14s ease, filter .2s ease;
  box-shadow: 0 16px 44px rgba(0,0,0,.32);
}
.role-card:hover{
  transform: translateY(-2px);
  filter: brightness(1.03) contrast(1.03);
}
.rc-img{
  width: 100%;
  aspect-ratio: 1 / 1;
  object-fit: cover;
  display:block;
  border-radius: 14px;
  border: 1px solid rgba(0,0,0,.32);
  box-shadow: 0 10px 24px rgba(0,0,0,.35);
}
.rc-overlay{
  position:absolute;
  left: 10px;
  right: 10px;
  bottom: 10px;
  padding: 10px;
  border-radius: 14px;
  background: linear-gradient(180deg, rgba(0,0,0,0), rgba(0,0,0,.68));
  pointer-events:none;
}
.rc-name{
  font-weight: 950;
  font-size: 13px;
  font-family: var(--serif);
  letter-spacing: .3px;
  color: rgba(255,255,255,.92);
  text-shadow: 0 2px 0 rgba(0,0,0,.45);
}
.rc-sub{
  color: rgba(255,255,255,.78);
  font-size: 12px;
  margin-top: 6px;
  font-family: var(--serif);
  text-shadow: 0 2px 0 rgba(0,0,0,.35);
}
.role-card .seal{
  position:absolute;
  right: 16px; top: 16px;
  width: 26px; height:26px;
  border-radius: 999px;
  background: radial-gradient(circle at 30% 30%, rgba(180,83,9,.55), rgba(120,53,15,.90));
  box-shadow: 0 10px 18px rgba(0,0,0,.22), inset 0 0 0 2px rgba(255,255,255,.08);
  opacity:.9;
  pointer-events:none;
}


/* Role card accents */
.rc-wolf{ box-shadow: inset 0 0 0 1px rgba(239,68,68,.18); }
.rc-seer{ box-shadow: inset 0 0 0 1px rgba(167,139,250,.22); }
.rc-doc{ box-shadow: inset 0 0 0 1px rgba(34,197,94,.18); }
.rc-vill{ box-shadow: inset 0 0 0 1px rgba(245,158,11,.18); }
.rc-hunt{ box-shadow: inset 0 0 0 1px rgba(59,130,246,.18); }
.rc-jest{ box-shadow: inset 0 0 0 1px rgba(236,72,153,.18); }

/* Reveal flip */
.center{ display:grid; place-items:center; min-height: calc(100vh - 110px); }
.maxw{ max-width: 760px; width: 100%; }
.reveal-preview{ display:grid; gap: 14px; place-items:center; padding: 10px 0 4px; }

.flip{ width: 340px; height: 220px; perspective: 1200px; cursor:pointer; }
.flip-inner{
  width:100%; height:100%;
  position:relative;
  transform-style: preserve-3d;
  transition: transform .7s cubic-bezier(.2,.8,.2,1);
}
.flip.is-flipped .flip-inner{ transform: rotateY(180deg); }
.flip-face{
  position:absolute; inset:0;
  border-radius: 22px;
  border: 1px solid rgba(255,255,255,.14);
  background: rgba(0,0,0,.18);
  display:grid; place-items:center;
  backface-visibility:hidden;
  overflow:hidden;
}
.flip-face:before{
  content:"";
  position:absolute; inset:-2px;
  background: radial-gradient(380px 160px at 30% 20%, rgba(255,255,255,.10), transparent 60%);
  pointer-events:none;
}
.flip-front{
  transform: rotateY(180deg);
}
.sigil{
  font-size: 56px;
  filter: drop-shadow(0 14px 24px rgba(0,0,0,.55));
}
.sigil.xl{ font-size: 74px; }
.sigil + .smallcap{ margin-top: 6px; }
.flip-front .h2{ text-align:center; padding: 0 14px; }
.flip-front .muted{ text-align:center; padding: 0 22px; margin-top: 6px; }

/* Timer ring */
.timer-wrap{ display:grid; place-items:center; gap: 12px; padding: 6px 0 2px; }
.ring{
  width: 220px; height:220px; border-radius: 999px;
  background:
    conic-gradient(var(--accent) 0deg, rgba(255,255,255,.08) 0deg);
  padding: 12px;
  box-shadow: var(--shadow);
  position:relative;
}
.ring:before{
  content:"";
  position:absolute; inset:-2px;
  border-radius: 999px;
  background: radial-gradient(120px 120px at 30% 30%, rgba(167,139,250,.25), transparent 60%);
  filter: blur(8px);
  opacity:.7;
  pointer-events:none;
}
.ring-inner{
  width:100%; height:100%;
  border-radius: 999px;
  background: rgba(0,0,0,.28);
  border: 1px solid rgba(255,255,255,.14);
  display:grid; place-items:center;
  text-align:center;
}
.bigtime{
  font-size: 54px;
  font-weight: 950;
  letter-spacing: -1px;
}
.ring.is-urgent{ animation: thump .55s ease-in-out infinite; }
@keyframes thump{
  0%,100%{ transform: scale(1); }
  50%{ transform: scale(1.03); }
}

/* Targets */
.target-grid{
  display:grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 10px;
}
@media (max-width: 980px){ .target-grid{ grid-template-columns: repeat(2, 1fr);} }

.target{
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.16);
  padding: 12px;
  cursor:pointer;
  position:relative;
  transition: transform .12s ease, filter .2s ease;
}
.target:hover{ transform: translateY(-2px); filter: brightness(1.07); }
.target.is-selected{
  border-color: rgba(167,139,250,.45);
  box-shadow: var(--glow);
}
.trow{ display:flex; align-items:center; gap:10px; }
.tmeta .p-name{ font-size: 13px; }
.tag{
  margin-top: 10px;
  display:inline-flex;
  padding: 5px 9px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.05);
  font-size: 12px;
  color: var(--muted);
}

/* Vote list */
.vote-list{ display:grid; gap: 10px; margin: 6px 0 4px; }
.vote{
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.16);
  padding: 12px;
}
.vtop{ display:flex; justify-content:space-between; align-items:center; gap: 12px; }
.vname{ font-weight: 900; }
.vnum{ color: var(--muted); font-family: var(--mono); font-size: 12px; }
.bar{
  height: 10px;
  margin-top: 10px;
  border-radius: 999px;
  background: rgba(255,255,255,.08);
  overflow:hidden;
  position:relative;
}
.fill{
  height:100%;
  width: 42%;
  border-radius: 999px;
  background: linear-gradient(90deg, rgba(167,139,250,.9), rgba(34,197,94,.75));
  box-shadow: var(--glow2);
  transition: width .6s cubic-bezier(.2,.8,.2,1);
}

/* Result */
.result-box{
  display:grid;
  grid-template-columns: 180px 1fr;
  gap: 14px;
  align-items:stretch;
}
@media (max-width: 980px){
  .result-box{ grid-template-columns: 1fr; }
}
.result-left{
  border-radius: 22px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.18);
  display:grid; place-items:center;
  position:relative;
  overflow:hidden;
}
.result-left:before{
  content:"";
  position:absolute; inset:-2px;
  background: radial-gradient(300px 140px at 30% 30%, rgba(239,68,68,.14), transparent 60%);
  pointer-events:none;
}
.result-right{ padding: 6px 2px; }

.toasts{ display:grid; gap:10px; margin: 14px 0 12px; }
.toast{
  display:flex; gap:10px; align-items:flex-start;
  padding: 10px 12px;
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.16);
  animation: toastIn .5s cubic-bezier(.2,.8,.2,1) both;
}
.toast:nth-child(2){ animation-delay: .08s; }
@keyframes toastIn{
  from{ opacity:0; transform: translateY(8px); filter: blur(6px); }
  to{ opacity:1; transform: translateY(0); filter: blur(0); }
}
.t-ico{ font-size: 18px; }
.t-title{ font-weight: 900; }
.t-sub{ color: var(--muted); font-size: 12px; margin-top: 2px; }

/* Modal */
.modal{ position:fixed; inset:0; display:none; z-index:50; }
.modal.is-open{ display:block; }
.modal-backdrop{
  position:absolute; inset:0;
  background: rgba(0,0,0,.55);
  backdrop-filter: blur(10px);
  animation: fade .2s ease both;
}
@keyframes fade{ from{ opacity:0; } to{ opacity:1; } }

.modal-card{
  position:absolute;
  left:50%; top:50%;
  transform: translate(-50%,-50%);
  width: min(720px, calc(100vw - 28px));
  border-radius: 26px;
  border: 1px solid rgba(255,255,255,.14);
  background: rgba(10,10,14,.65);
  box-shadow: var(--shadow);
  overflow:hidden;
  animation: pop .26s cubic-bezier(.2,.8,.2,1) both;
}
@keyframes pop{
  from{ opacity:0; transform: translate(-50%,-46%) scale(.98); filter: blur(10px); }
  to{ opacity:1; transform: translate(-50%,-50%) scale(1); filter: blur(0); }
}

.modal-head{
  display:flex; align-items:center; justify-content:space-between;
  padding: 14px 16px;
  border-bottom: 1px solid rgba(255,255,255,.10);
}
.modal-title{ font-weight: 950; letter-spacing: .2px; }
.iconbtn{
  width: 38px; height:38px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.06);
  color: var(--text);
  cursor:pointer;
}
.modal-body{ padding: 16px; }
.modal-foot{
  padding: 12px 16px 16px;
  border-top: 1px solid rgba(255,255,255,.10);
}
.reveal-hero{
  position:relative;
  border-radius: 22px;
  border: 1px solid rgba(255,255,255,.10);
  background: radial-gradient(500px 220px at 50% 0%, rgba(167,139,250,.12), transparent 60%),
              rgba(0,0,0,.18);
  overflow:hidden;
  padding: 18px 14px;
  display:grid; place-items:center;
}
.spot{
  position:absolute;
  width: 520px; height:520px;
  border-radius: 999px;
  background: radial-gradient(circle at 50% 50%, rgba(255,255,255,.14), transparent 55%);
  filter: blur(10px);
  opacity: 0;
  transform: translate(-25%, -25%) scale(.85);
  transition: opacity .25s ease, transform .35s ease;
  pointer-events:none;
}
.spot.is-on{
  opacity: 1;
  transform: translate(-18%, -18%) scale(1);
}
.reveal-card{
  width: min(520px, 92%);
  height: 260px;
  border-radius: 24px;
  border: 1px solid rgba(255,255,255,.14);
  background: rgba(0,0,0,.20);
  position:relative;
  transform-style: preserve-3d;
  transition: transform .7s cubic-bezier(.2,.8,.2,1);
  box-shadow: var(--shadow);
  overflow:hidden;
}
.reveal-card.is-flipped{ transform: rotateY(180deg); }
.reveal-face{
  position:absolute; inset:0;
  display:grid; place-items:center;
  backface-visibility:hidden;
}
.face-front{ transform: rotateY(180deg); padding: 0 18px; text-align:center; }
.face-front .muted{ margin-top: 6px; }
.chips{ display:flex; gap:8px; justify-content:center; margin-top: 12px; flex-wrap:wrap; }
.chip{
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.06);
  font-size: 12px;
  color: var(--muted);
}

/* Global effects toggles */
.fog-on .stage:before{
  content:"";
  position: fixed; inset:-40px;
  background:
    radial-gradient(900px 420px at 20% 35%, rgba(255,255,255,.08), transparent 60%),
    radial-gradient(720px 360px at 80% 55%, rgba(255,255,255,.05), transparent 62%),
    radial-gradient(980px 520px at 50% 80%, rgba(255,255,255,.04), transparent 64%);
  filter: blur(18px);
  opacity:.65;
  animation: fogMove 14s ease-in-out infinite;
  pointer-events:none;
  z-index: 1;
}
@keyframes fogMove{
  0%,100%{ transform: translate3d(-10px,-6px,0); }
  50%{ transform: translate3d(12px,10px,0); }
}
.grain-on:after{
  content:"";
  position: fixed; inset:0;
  background-image: repeating-linear-gradient(0deg, rgba(255,255,255,.03) 0 1px, transparent 1px 2px);
  opacity:.08;
  pointer-events:none;
  z-index: 3;
  mix-blend-mode: overlay;
}
.scan-on:before{
  content:"";
  position: fixed; inset:0;
  background:
    repeating-linear-gradient(180deg, rgba(255,255,255,.05) 0 1px, transparent 1px 6px);
  opacity:.10;
  pointer-events:none;
  z-index: 4;
  mix-blend-mode: overlay;
}

.glow-on .logo,
.glow-on .pill,
.glow-on .fill,
.glow-on .ring{
  filter: drop-shadow(var(--glow));
}

/* Motion intensity */
.motion-low .role-card:hover{ transform: translateY(-1px); }
.motion-high .role-card:hover{ transform: translateY(-4px) rotateX(10deg); }
.motion-low .scene{ animation-duration: .22s; }
.motion-high .scene{ animation-duration: .5s; }

/* Shake demo */
.shake{
  animation: shake .32s ease-in-out both;
}
@keyframes shake{
  0%{ transform: translateX(0); }
  20%{ transform: translateX(-6px); }
  40%{ transform: translateX(6px); }
  60%{ transform: translateX(-4px); }
  80%{ transform: translateX(4px); }
  100%{ transform: translateX(0); }
}

/* Themes via classes */
.theme-mystic{
  /* Moonlit Forest */
  --wood1:#1a120a;
  --wood2:#0f0a06;
  --accent:#d6b15a;
  --accent2:#7c3aed;
}
.theme-candle{
  /* Candlelit Tavern */
  --wood1:#2a160a;
  --wood2:#140b06;
  --accent:#d6b15a;
  --accent2:#b45309;
}
.theme-neon{
  /* Enchanted Sigils (still medieval, but magic) */
  --wood1:#14101a;
  --wood2:#07060c;
  --accent:#22d3ee;
  --accent2:#fb7185;
  --paper:#efe6cf;
  --paper2:#e4d4ab;
}
.theme-minimal{
  /* Ink & Parchment */
  --wood1:#151212;
  --wood2:#0b0a0a;
  --accent:#e5e7eb;
  --accent2:#a3a3a3;
  --paper:#f3ead4;
  --paper2:#e8d6b1;
}

/* Night/day tweak */
.is-day body{}
.app.is-day{
  --bg0:#0b1324;
  --bg1:#0f1c38;
}
.app.is-day #fxCanvas{ mix-blend-mode: screen; opacity:.65; }

/* Make sure stage content is above fog layer */
.stage > *{ position:relative; z-index:2; }

/* Medieval typography */
.h1,.h2,.title,.modal-title{ font-family: var(--serif); }
.kicker{ font-family: var(--serif); letter-spacing: .6px; }

.flip-front .muted, .face-front .muted{
  color: rgba(27,26,23,.70) !important;
}
.face-front .chip{
  color: rgba(27,26,23,.72) !important;
  border-color: rgba(27,26,23,.18) !important;
  background: rgba(214,177,90,.10) !important;
}


/* Card back (simple medieval pattern) */
.cardback{
  width: 70%;
  height: 70%;
  border-radius: 18px;
  border: 1px solid rgba(0,0,0,.35);
  background:
    radial-gradient(circle at 30% 30%, rgba(214,177,90,.28), transparent 55%),
    radial-gradient(circle at 70% 60%, rgba(180,83,9,.22), transparent 60%),
    repeating-linear-gradient(45deg, rgba(0,0,0,.18) 0 6px, rgba(255,255,255,.06) 6px 12px),
    linear-gradient(180deg, rgba(0,0,0,.15), rgba(0,0,0,.28));
  box-shadow: 0 14px 30px rgba(0,0,0,.35);
}
.reveal-img{
  width: min(360px, 88%);
  aspect-ratio: 1 / 1;
  object-fit: cover;
  border-radius: 18px;
  border: 1px solid rgba(0,0,0,.35);
  box-shadow: 0 18px 46px rgba(0,0,0,.35);
  margin-bottom: 10px;
}

/* Reveal containers (dark frame around official card images) */
.flip-face, .reveal-card{
  background: rgba(0,0,0,.14);
}

/* Card images (official assets) */
.card-img{
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: 18px;
  display:block;
  box-shadow: 0 14px 40px rgba(0,0,0,.28);
}
.flip-back-img, .modal-back-img{
  border-radius: 20px;
  border: 1px solid rgba(0,0,0,.20);
}
.flip-face.flip-back, .reveal-face.face-back{
  padding: 10px;
  gap: 10px;
}
.flip-face.flip-back{
  display:grid;
  grid-template-rows: 1fr auto;
}
.reveal-face.face-back{
  display:grid;
  grid-template-rows: 1fr auto;
  align-items:center;
  justify-items:center;
}

====================================================================================================
PATH: web\static\tv-game.css
----------------------------
/* =====================================================
   LOUP-GAROU TV - IMMERSIVE MEDIEVAL GAME MASTER UI
   ===================================================== */

:root {
  /* Colors */
  --bg-night: #0a0d15;
  --bg-night-deep: #050810;
  --bg-day: #1a1510;
  --bg-dawn: #2a1a15;
  
  --gold: #d4a24c;
  --gold-dim: rgba(212, 162, 76, 0.6);
  --gold-glow: rgba(212, 162, 76, 0.3);
  
  --blood: #8b0000;
  --blood-glow: rgba(139, 0, 0, 0.4);
  
  --silver: #c0c0c0;
  --text: #f5f0e8;
  --text-dim: rgba(245, 240, 232, 0.6);
  
  --surface: rgba(255, 255, 255, 0.06);
  --surface-hover: rgba(255, 255, 255, 0.12);
  --border: rgba(255, 255, 255, 0.1);
  
  /* Typography */
  --font: 'Segoe UI', system-ui, -apple-system, sans-serif;
  --font-display: 'Georgia', 'Times New Roman', serif;
  
  /* Spacing */
  --radius: 16px;
  --radius-lg: 24px;
}

* { box-sizing: border-box; margin: 0; padding: 0; }

html {
  min-height: 100%;
  font-family: var(--font);
  background: var(--bg-night);
  color: var(--text);
}

body {
  min-height: 100vh;
  font-family: var(--font);
  background: var(--bg-night);
  color: var(--text);
  overflow-x: hidden;
  overflow-y: auto !important;
}

/* =====================================================
   APP CONTAINER & CANVAS
   ===================================================== */

.tv-app {
  position: relative;
  width: 100%;
  min-height: 100vh;
  padding-bottom: 100px;
  transition: background 1s ease;
}

.tv-app.day-mode {
  background: linear-gradient(180deg, #2a2015 0%, #1a1510 100%);
}

#fxCanvas {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 0;
}

.ambient-particles {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 1;
}

/* =====================================================
   SCREENS
   ===================================================== */

.screen {
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  padding: 20px 24px 120px;
  min-height: calc(100vh - 80px);
  width: 100%;
  z-index: 10;
}

.screen.active {
  display: flex;
}

/* =====================================================
   LOBBY SCREEN
   ===================================================== */

.lobby-container {
  width: 100%;
  max-width: 900px;
  text-align: center;
  padding-top: 20px;
}

.lobby-header {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 30px;
  margin-bottom: 16px;
}

.torch {
  font-size: 36px;
  animation: flicker 2s infinite alternate;
}

@keyframes flicker {
  0%, 100% { opacity: 1; transform: scale(1); }
  25% { opacity: 0.9; transform: scale(1.02); }
  50% { opacity: 1; transform: scale(0.98); }
  75% { opacity: 0.85; transform: scale(1.01); }
}

.title-crest {
  text-align: center;
}

.crest-icon {
  font-size: 50px;
  filter: drop-shadow(0 0 20px rgba(139, 0, 0, 0.5));
  animation: pulse-glow 3s infinite;
}

@keyframes pulse-glow {
  0%, 100% { filter: drop-shadow(0 0 20px rgba(139, 0, 0, 0.5)); }
  50% { filter: drop-shadow(0 0 35px rgba(139, 0, 0, 0.8)); }
}

.game-title {
  font-family: var(--font-display);
  font-size: 42px;
  font-weight: 700;
  letter-spacing: 3px;
  text-transform: uppercase;
  background: linear-gradient(180deg, var(--gold) 0%, #8b6914 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-shadow: none;
}

.game-subtitle {
  font-size: 14px;
  color: var(--text-dim);
  font-style: italic;
  margin-top: 2px;
}

/* Configuration Panel */
.config-panel {
  background: rgba(20, 15, 10, 0.9);
  border: 2px solid var(--gold-dim);
  border-radius: var(--radius);
  margin-bottom: 16px;
  overflow: hidden;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.05);
}

.config-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 14px 20px;
  cursor: pointer;
  transition: background 0.2s;
  background: linear-gradient(180deg, rgba(212, 162, 76, 0.15) 0%, transparent 100%);
  border-bottom: 1px solid var(--border);
}

.config-header:hover {
  background: linear-gradient(180deg, rgba(212, 162, 76, 0.25) 0%, transparent 100%);
}

.config-header span:first-child {
  font-weight: 700;
  letter-spacing: 1px;
}

.toggle-icon {
  transition: transform 0.3s;
  color: var(--gold);
}

.config-panel.open .toggle-icon {
  transform: rotate(180deg);
}

.config-body {
  display: none;
  padding: 20px;
}

.config-panel.open .config-body {
  display: block;
}

.config-section {
  margin-bottom: 24px;
}

.config-section:last-of-type {
  margin-bottom: 16px;
}

.config-section h3 {
  font-size: 13px;
  color: var(--gold);
  margin-bottom: 14px;
  text-transform: uppercase;
  letter-spacing: 2px;
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.config-section h3::before,
.config-section h3::after {
  content: '';
  flex: 1;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--gold-dim), transparent);
}

/* Timer inputs - medieval scroll style */
.config-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 12px;
}

.config-item {
  text-align: center;
}

.config-item label {
  display: block;
  font-size: 11px;
  color: var(--text-dim);
  margin-bottom: 8px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.config-item input {
  width: 100%;
  padding: 12px 8px;
  background: rgba(0, 0, 0, 0.4);
  border: 2px solid var(--border);
  border-radius: 10px;
  color: var(--gold);
  font-size: 20px;
  font-weight: 700;
  text-align: center;
  transition: all 0.2s;
}

.config-item input:focus {
  outline: none;
  border-color: var(--gold);
  box-shadow: 0 0 20px rgba(212, 162, 76, 0.3);
}

/* Role Cards Grid */
.roles-cards-grid {
  display: flex;
  justify-content: center;
  gap: 16px;
  flex-wrap: wrap;
}

.role-config-card {
  width: 100px;
  cursor: pointer;
  transition: all 0.3s;
  position: relative;
}

.role-config-card.disabled {
  opacity: 0.4;
  cursor: not-allowed;
  filter: grayscale(0.8);
}

.role-config-card.active {
  transform: scale(1.05);
}

.role-config-card .card-image {
  width: 100px;
  height: 100px;
  border-radius: 12px;
  overflow: hidden;
  border: 3px solid var(--border);
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
  transition: all 0.3s;
  position: relative;
}

.role-config-card.active .card-image {
  border-color: var(--gold);
  box-shadow: 0 0 24px rgba(212, 162, 76, 0.5);
}

.role-config-card .card-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.role-config-card .card-image::after {
  content: '✓';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0);
  font-size: 36px;
  color: var(--gold);
  text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
  transition: transform 0.3s;
  pointer-events: none;
}

.role-config-card.active .card-image::after {
  transform: translate(-50%, -50%) scale(1);
}

.role-config-card .card-name {
  text-align: center;
  margin-top: 8px;
  font-size: 12px;
  font-weight: 600;
}

.role-config-card .card-badge {
  position: absolute;
  top: -8px;
  right: -8px;
  background: var(--blood);
  color: white;
  font-size: 9px;
  padding: 3px 8px;
  border-radius: 10px;
  font-weight: 700;
  text-transform: uppercase;
}

.role-config-card input {
  display: none;
}

.btn-config {
  width: 100%;
  padding: 14px;
  background: linear-gradient(135deg, var(--gold) 0%, #b8860b 100%);
  border: none;
  border-radius: 10px;
  color: #1a1512;
  font-weight: 700;
  font-size: 15px;
  cursor: pointer;
  transition: all 0.2s;
  text-transform: uppercase;
  letter-spacing: 1px;
  box-shadow: 0 4px 16px rgba(212, 162, 76, 0.3);
}

.btn-config:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 24px rgba(212, 162, 76, 0.5);
}

/* Village Circle */
.village-circle {
  position: relative;
  width: 280px;
  height: 280px;
  margin: 0 auto 16px;
}

.village-center {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
}

.player-count {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.player-count span {
  font-size: 56px;
  font-weight: 800;
  line-height: 1;
  color: var(--gold);
}

.player-count small {
  font-size: 11px;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 2px;
}

.players-ring {
  position: absolute;
  inset: 0;
}

.player-token {
  position: absolute;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  transform: translate(-50%, -50%);
  animation: fadeInToken 0.5s ease;
}

@keyframes fadeInToken {
  from { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
  to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
}

.player-token .avatar {
  width: 44px;
  height: 44px;
  border-radius: 50%;
  background: linear-gradient(135deg, #3a3530 0%, #2a2520 100%);
  border: 2px solid var(--gold-dim);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  font-weight: 700;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
}

.player-token .name {
  font-size: 11px;
  font-weight: 600;
  max-width: 70px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* Join Banner */
.join-banner {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  padding: 12px 20px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  margin-bottom: 16px;
}

.join-qr {
  font-size: 32px;
}

.join-info {
  text-align: left;
}

.join-label {
  font-size: 12px;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 1px;
}

.join-info code {
  font-size: 16px;
  color: var(--gold);
}

/* Start Button */
.btn-start {
  display: inline-flex;
  align-items: center;
  gap: 10px;
  padding: 16px 36px;
  background: linear-gradient(135deg, var(--blood) 0%, #5a0000 100%);
  border: 2px solid rgba(255, 255, 255, 0.1);
  border-radius: var(--radius-lg);
  color: var(--text);
  font-size: 18px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.3s;
  box-shadow: 0 6px 24px rgba(139, 0, 0, 0.4);
}

.btn-start:hover:not(:disabled) {
  transform: scale(1.05);
  box-shadow: 0 10px 40px rgba(139, 0, 0, 0.6);
}

.btn-start:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-icon {
  font-size: 22px;
}

.min-players-hint {
  margin-top: 8px;
  font-size: 12px;
  color: var(--text-dim);
}

/* =====================================================
   NIGHT SCREEN
   ===================================================== */

.night-container {
  text-align: center;
  width: 100%;
  max-width: 800px;
}

.moon-phase {
  position: relative;
  margin-bottom: 24px;
}

.moon {
  font-size: 100px;
  animation: moonFloat 4s ease-in-out infinite;
}

@keyframes moonFloat {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
}

.stars {
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  font-size: 24px;
  animation: twinkle 2s infinite;
}

@keyframes twinkle {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}

.night-info h2 {
  font-family: var(--font-display);
  font-size: 42px;
  margin-bottom: 8px;
}

.night-subtitle {
  font-size: 18px;
  color: var(--text-dim);
}

.night-timer {
  margin: 32px 0;
}

.timer-circle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 120px;
  height: 120px;
  border: 4px solid var(--gold);
  border-radius: 50%;
  font-size: 48px;
  font-weight: 800;
  font-variant-numeric: tabular-nums;
}

.timer-circle.urgent {
  border-color: var(--blood);
  animation: pulse 0.5s infinite;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

.current-action {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 16px;
  padding: 20px 32px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  margin-bottom: 32px;
}

.action-icon {
  font-size: 40px;
}

.action-text {
  font-size: 20px;
  font-weight: 600;
}

.sleeping-village {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 16px;
}

.sleeping-player {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
}

.sleeping-player .avatar {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  background: linear-gradient(135deg, #2a2520 0%, #1a1510 100%);
  border: 2px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  font-weight: 700;
  position: relative;
}

.sleeping-player .zzz {
  position: absolute;
  top: -8px;
  right: -8px;
  font-size: 16px;
  animation: zzz 2s infinite;
}

@keyframes zzz {
  0%, 100% { transform: translateY(0) scale(1); opacity: 1; }
  50% { transform: translateY(-5px) scale(1.1); opacity: 0.7; }
}

.sleeping-player .name {
  font-size: 11px;
  color: var(--text-dim);
}

/* =====================================================
   DAWN / DEATH REVEAL SCREEN
   ===================================================== */

.dawn-container {
  text-align: center;
  width: 100%;
  max-width: 600px;
}

.sun-rising {
  position: relative;
  margin-bottom: 24px;
}

.sun-rising .sun {
  font-size: 80px;
  animation: sunRise 2s ease-out;
}

@keyframes sunRise {
  from { transform: translateY(50px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

.dawn-title {
  font-family: var(--font-display);
  font-size: 36px;
  margin-bottom: 32px;
}

.death-theater {
  margin-bottom: 24px;
}

.death-stage {
  perspective: 1000px;
}

/* Multiple deaths container */
.deaths-row {
  display: flex;
  justify-content: center;
  align-items: flex-start;
  gap: 24px;
  flex-wrap: wrap;
  margin-bottom: 20px;
}

.death-card {
  position: relative;
  width: 150px;
  display: flex;
  flex-direction: column;
  align-items: center;
  animation: deathReveal 1s ease-out;
}

@keyframes deathReveal {
  0% { transform: scale(0.5) rotateY(180deg); opacity: 0; }
  50% { transform: scale(1.1) rotateY(90deg); opacity: 1; }
  100% { transform: scale(1) rotateY(0deg); opacity: 1; }
}

.death-card .card-glow {
  position: absolute;
  top: -15px;
  left: -15px;
  right: -15px;
  bottom: 60px;
  background: radial-gradient(circle, rgba(139, 0, 0, 0.4) 0%, transparent 70%);
  border-radius: 20px;
  animation: glowPulse 2s infinite;
  pointer-events: none;
}

.death-card.lover .card-glow {
  background: radial-gradient(circle, rgba(255, 105, 180, 0.4) 0%, transparent 70%);
}

@keyframes glowPulse {
  0%, 100% { opacity: 0.5; transform: scale(1); }
  50% { opacity: 1; transform: scale(1.05); }
}

.death-card .card-img {
  width: 130px;
  height: 130px;
  border-radius: var(--radius);
  border: 3px solid var(--blood);
  box-shadow: 0 10px 40px rgba(139, 0, 0, 0.5);
  overflow: hidden;
}

.death-card .card-img img {
  width: 130px;
  height: 130px;
  object-fit: cover;
  display: block;
}

.death-card.lover .card-img {
  border-color: #ff69b4;
  box-shadow: 0 10px 40px rgba(255, 105, 180, 0.5);
}

.death-info {
  margin-top: 12px;
  text-align: center;
}

.victim-name {
  font-size: 18px;
  font-weight: 800;
}

.victim-role {
  font-size: 14px;
  color: var(--gold);
  margin: 2px 0;
}

.death-cause {
  font-size: 11px;
  color: var(--text-dim);
  font-style: italic;
}

.death-queue-indicator {
  margin-top: 16px;
  font-size: 14px;
  color: var(--text-dim);
}

.no-death {
  padding: 40px;
}

.miracle-icon {
  font-size: 60px;
  margin-bottom: 16px;
}

/* =====================================================
   DAY SCREEN
   ===================================================== */

.day-container {
  text-align: center;
  width: 100%;
  max-width: 800px;
}

.day-header {
  margin-bottom: 24px;
}

.sun-icon {
  font-size: 60px;
  animation: sunPulse 3s infinite;
}

@keyframes sunPulse {
  0%, 100% { filter: drop-shadow(0 0 20px rgba(255, 200, 50, 0.6)); }
  50% { filter: drop-shadow(0 0 40px rgba(255, 200, 50, 0.9)); }
}

.day-header h2 {
  font-family: var(--font-display);
  font-size: 36px;
  margin: 8px 0;
}

.day-subtitle {
  color: var(--text-dim);
}

.day-timer {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  margin-bottom: 32px;
}

.hourglass {
  font-size: 32px;
  animation: hourglassFlip 2s infinite;
}

@keyframes hourglassFlip {
  0%, 45% { transform: rotate(0deg); }
  50%, 95% { transform: rotate(180deg); }
}

.day-timer span {
  font-size: 48px;
  font-weight: 800;
  font-variant-numeric: tabular-nums;
}

.council-circle {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 20px;
  margin-bottom: 24px;
}

.council-member {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  padding: 12px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  min-width: 80px;
}

.council-member .avatar {
  width: 52px;
  height: 52px;
  border-radius: 50%;
  background: linear-gradient(135deg, #3a3530 0%, #2a2520 100%);
  border: 2px solid var(--gold-dim);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  font-weight: 700;
}

.council-member .name {
  font-size: 13px;
  font-weight: 600;
}

.discussion-hint {
  padding: 16px;
  background: var(--surface);
  border-radius: var(--radius);
}

.discussion-hint p {
  font-size: 18px;
}

/* =====================================================
   VOTE SCREEN
   ===================================================== */

.vote-container {
  text-align: center;
  width: 100%;
  max-width: 900px;
}

.vote-header {
  margin-bottom: 24px;
}

.scales {
  font-size: 60px;
  animation: scalesSwing 3s ease-in-out infinite;
}

@keyframes scalesSwing {
  0%, 100% { transform: rotate(-5deg); }
  50% { transform: rotate(5deg); }
}

.vote-header h2 {
  font-family: var(--font-display);
  font-size: 36px;
  margin: 8px 0;
}

.vote-timer {
  margin-bottom: 24px;
}

.vote-timer span {
  font-size: 56px;
  font-weight: 800;
  font-variant-numeric: tabular-nums;
}

.vote-progress {
  max-width: 400px;
  margin: 0 auto 32px;
}

.progress-bar {
  height: 12px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 6px;
  overflow: hidden;
  margin-bottom: 8px;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--gold) 0%, #b8860b 100%);
  width: 0%;
  transition: width 0.3s ease;
}

.progress-text {
  font-size: 14px;
  color: var(--text-dim);
}

.vote-arena {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 16px;
}

.vote-candidate {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  padding: 16px;
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  min-width: 100px;
  transition: all 0.3s;
}

.vote-candidate.leading {
  border-color: var(--blood);
  background: rgba(139, 0, 0, 0.2);
  transform: scale(1.05);
}

.vote-candidate .avatar {
  width: 56px;
  height: 56px;
  border-radius: 50%;
  background: linear-gradient(135deg, #3a3530 0%, #2a2520 100%);
  border: 2px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 22px;
  font-weight: 700;
}

.vote-candidate .name {
  font-size: 14px;
  font-weight: 600;
}

.vote-candidate .votes {
  font-size: 28px;
  font-weight: 800;
  color: var(--gold);
}

.vote-candidate .vote-bar {
  width: 100%;
  height: 4px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 2px;
  overflow: hidden;
}

.vote-candidate .vote-bar-fill {
  height: 100%;
  background: var(--blood);
  transition: width 0.3s;
}

/* =====================================================
   EXECUTION SCREEN
   ===================================================== */

.execution-container {
  text-align: center;
  width: 100%;
  max-width: 600px;
}

.verdict-title {
  font-family: var(--font-display);
  font-size: 42px;
  margin-bottom: 32px;
}

.execution-stage {
  position: relative;
  margin-bottom: 24px;
}

.gallows {
  position: absolute;
  top: -30px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 36px;
  opacity: 0.6;
}

.condemned-card {
  display: inline-block;
  position: relative;
}

.condemned-card img {
  width: 180px;
  height: 180px;
  object-fit: cover;
  border-radius: var(--radius);
  border: 4px solid var(--blood);
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
  animation: condemnedReveal 1s ease-out;
}

@keyframes condemnedReveal {
  from { transform: scale(0.8) rotateY(90deg); opacity: 0; }
  to { transform: scale(1) rotateY(0deg); opacity: 1; }
}

.condemned-info {
  margin-top: 16px;
}

.condemned-name {
  font-size: 28px;
  font-weight: 800;
}

.condemned-role {
  font-size: 18px;
  color: var(--gold);
}

.vote-tally {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 8px;
}

.tally-item {
  padding: 8px 16px;
  background: var(--surface);
  border-radius: 20px;
  font-size: 14px;
}

.tally-item .count {
  color: var(--gold);
  font-weight: 700;
}

/* =====================================================
   GAME OVER SCREEN
   ===================================================== */

.gameover-container {
  text-align: center;
  width: 100%;
  max-width: 900px;
}

.victory-banner {
  margin-bottom: 40px;
  padding: 32px;
  background: linear-gradient(135deg, rgba(212, 162, 76, 0.2) 0%, transparent 100%);
  border-radius: var(--radius-lg);
  animation: victoryGlow 2s infinite;
}

@keyframes victoryGlow {
  0%, 100% { box-shadow: 0 0 40px rgba(212, 162, 76, 0.3); }
  50% { box-shadow: 0 0 80px rgba(212, 162, 76, 0.5); }
}

.victory-banner.wolves {
  background: linear-gradient(135deg, rgba(139, 0, 0, 0.3) 0%, transparent 100%);
  animation: wolvesVictory 2s infinite;
}

@keyframes wolvesVictory {
  0%, 100% { box-shadow: 0 0 40px rgba(139, 0, 0, 0.3); }
  50% { box-shadow: 0 0 80px rgba(139, 0, 0, 0.5); }
}

.victory-icon {
  font-size: 80px;
  margin-bottom: 16px;
}

.victory-title {
  font-family: var(--font-display);
  font-size: 48px;
  margin-bottom: 8px;
}

.victory-team {
  font-size: 24px;
  color: var(--gold);
}

.final-reveal h3 {
  font-size: 14px;
  color: var(--text-dim);
  margin-bottom: 24px;
  text-transform: uppercase;
  letter-spacing: 2px;
  text-align: center;
}

.all-roles {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  align-items: flex-start;
  gap: 24px;
  margin-bottom: 32px;
  padding: 0 20px;
}

.role-card {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100px;
  text-align: center;
}

.role-card .card-img {
  width: 85px;
  height: 85px;
  border-radius: 12px;
  overflow: hidden;
  border: 3px solid var(--border);
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
  margin-bottom: 10px;
  opacity: 0;
  transform: scale(0.8) rotateY(90deg);
  transition: all 0.6s ease;
}

.role-card.revealed .card-img {
  opacity: 1;
  transform: scale(1) rotateY(0deg);
}

.role-card .card-img img {
  width: 85px;
  height: 85px;
  object-fit: cover;
  display: block;
}

.role-card.wolf .card-img {
  border-color: var(--blood);
  box-shadow: 0 4px 20px rgba(139, 0, 0, 0.5);
}

.role-card .name {
  font-size: 13px;
  font-weight: 600;
  margin-bottom: 2px;
}

.role-card .role {
  font-size: 11px;
  color: var(--gold);
}

.btn-reset {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 16px 32px;
  background: var(--gold);
  border: none;
  border-radius: var(--radius);
  color: #1a1512;
  font-size: 18px;
  font-weight: 700;
  cursor: pointer;
  transition: transform 0.2s;
}

.btn-reset:hover {
  transform: scale(1.05);
}

/* =====================================================
   GRAVEYARD
   ===================================================== */

.graveyard {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: linear-gradient(180deg, transparent 0%, rgba(10, 13, 21, 0.98) 25%);
  padding: 16px 24px 20px;
  z-index: 50;
}

.graveyard-header {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 12px;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: var(--text-dim);
}

.grave-icon {
  font-size: 20px;
}

.graveyard-tombs {
  display: flex;
  gap: 16px;
  overflow-x: auto;
  padding-bottom: 8px;
}

.tomb {
  display: flex;
  align-items: center;
  gap: 14px;
  padding: 12px 16px;
  background: rgba(0, 0, 0, 0.6);
  border: 2px solid var(--border);
  border-radius: 16px;
  flex-shrink: 0;
}

.tomb .tomb-card {
  width: 60px;
  height: 60px;
  border-radius: 10px;
  overflow: hidden;
  border: 2px solid var(--border);
  flex-shrink: 0;
}

.tomb .tomb-card img {
  width: 60px;
  height: 60px;
  object-fit: cover;
  display: block;
  filter: grayscale(0.6) brightness(0.8);
}

.tomb.wolf .tomb-card {
  border-color: var(--blood);
}

.tomb.wolf .tomb-card img {
  filter: grayscale(0.4) brightness(0.85);
}

.tomb .info .name {
  font-size: 15px;
  font-weight: 700;
  margin-bottom: 2px;
}

.tomb .info .role {
  font-size: 13px;
  color: var(--gold);
}

/* =====================================================
   NARRATOR PANEL
   ===================================================== */

.narrator-btn {
  position: fixed;
  top: 20px;
  right: 20px;
  width: 48px;
  height: 48px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
  cursor: pointer;
  z-index: 100;
  transition: transform 0.2s;
}

.narrator-btn:hover {
  transform: scale(1.1);
}

.narrator-panel {
  position: fixed;
  top: 0;
  right: -400px;
  width: 380px;
  height: 100%;
  background: rgba(10, 13, 21, 0.98);
  border-left: 1px solid var(--border);
  z-index: 200;
  transition: right 0.3s ease;
  display: flex;
  flex-direction: column;
}

.narrator-panel.open {
  right: 0;
}

.narrator-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 20px;
  border-bottom: 1px solid var(--border);
}

.narrator-header button {
  background: none;
  border: none;
  color: var(--text);
  font-size: 20px;
  cursor: pointer;
}

.narrator-scroll {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  font-size: 13px;
  line-height: 1.6;
  white-space: pre-wrap;
  font-family: monospace;
}

/* =====================================================
   CONNECTION STATUS
   ===================================================== */

.connection-status {
  position: fixed;
  top: 20px;
  left: 20px;
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  background: var(--surface);
  border-radius: 20px;
  font-size: 12px;
  z-index: 100;
}

.status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #e74c3c;
}

.connection-status.connected .status-dot {
  background: #27ae60;
}

/* =====================================================
   RESPONSIVE
   ===================================================== */

@media (max-width: 768px) {
  .game-title { font-size: 36px; }
  .crest-icon { font-size: 60px; }
  .torch { display: none; }
  .village-circle { width: 300px; height: 300px; }
  .player-count span { font-size: 48px; }
  .config-grid { grid-template-columns: 1fr 1fr; }
}

/* =====================================================
   SCROLLBAR
   ===================================================== */

::-webkit-scrollbar { width: 6px; height: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

====================================================================================================
PATH: web\static\tv-game.js
---------------------------
/**
 * Loup-Garou TV - Immersive Game Master Interface
 * Features:
 * - Sequential death announcements
 * - Game configuration (timers, roles)
 * - Medieval theme with animations
 * - Enhanced vote visualization
 */

document.addEventListener('DOMContentLoaded', init);

function init() {
  console.log('[TV] === GAME MASTER UI STARTING ===');
  
  const $ = id => document.getElementById(id);
  
  // Parse URL for backend
  const params = new URLSearchParams(window.location.search);
  const host = params.get('backendHost') || window.location.hostname;
  const port = params.get('backendPort') || window.location.port || '8000';
  const portPart = port ? `:${port}` : '';
  
  const API_URL = `${window.location.protocol}//${host}${portPart}`;
  const WS_URL = `${window.location.protocol === 'https:' ? 'wss' : 'ws'}://${host}${portPart}`;
  
  console.log('[TV] API:', API_URL);
  
  // Game state
  let state = {
    phase: 'LOBBY',
    night_count: 0,
    day_count: 0,
    alive: [],
    dead: [],
    started: false,
    winner: null,
    timers: null
  };
  
  let ws = null;
  let currentScreen = 'screenLobby';
  let lastPhase = 'LOBBY';
  let deathQueue = [];
  let deathIndex = 0;
  let previousAliveIds = [];
  
  // Configuration (can be modified before game starts)
  let config = {
    nightAction: 22,
    dayDiscuss: 15,
    voteTime: 25,
    resultTime: 5
  };
  
  // FX
  const fx = window.LGFX?.init($('fxCanvas'), { mode: 'night' });
  
  // ============ HELPERS ============
  function getRoleImage(role) {
    const images = {
      villager: 'villager.jpg',
      werewolf: 'werewolf.jpg',
      seer: 'voyante.jpg',
      witch: 'sorcerer.jpg',
      cupid: 'cupidon.jpg',
      hunter: 'hunter.jpg'
    };
    return '/static/cards/' + (images[role] || 'verso.jpg');
  }
  
  function getRoleName(role) {
    const names = {
      villager: 'Villageois',
      werewolf: 'Loup-Garou',
      seer: 'Voyante',
      witch: 'Sorcière',
      cupid: 'Cupidon',
      hunter: 'Chasseur'
    };
    return names[role] || '???';
  }
  
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text || '';
    return div.innerHTML;
  }
  
  // ============ SCREENS ============
  const allScreens = [
    'screenLobby', 'screenNight', 'screenDawn', 
    'screenDay', 'screenVote', 'screenExecution', 'screenGameOver'
  ];
  
  function showScreen(screenId, animate = true) {
    console.log('[TV] Showing screen:', screenId);
    
    allScreens.forEach(id => {
      const el = $(id);
      if (el) {
        if (id === screenId) {
          el.style.display = 'flex';
          if (animate) {
            el.style.opacity = '0';
            setTimeout(() => { el.style.opacity = '1'; }, 50);
          }
          el.classList.add('active');
        } else {
          el.classList.remove('active');
          el.style.display = 'none';
        }
      }
    });
    
    currentScreen = screenId;
    
    // Update app theme
    const app = $('app');
    if (app) {
      app.classList.toggle('day-mode', 
        screenId === 'screenDay' || 
        screenId === 'screenVote' || 
        screenId === 'screenExecution'
      );
    }
    
    fx?.burst({ kind: 'magic', count: 15 });
  }
  
  // ============ CONNECTION ============
  function connect() {
    const url = `${WS_URL}/ws?client=tv`;
    console.log('[TV] Connecting:', url);
    
    ws = new WebSocket(url);
    
    ws.onopen = () => {
      console.log('[TV] Connected');
      setConnected(true);
      fx?.burst({ kind: 'magic', count: 20 });
    };
    
    ws.onclose = () => {
      console.log('[TV] Disconnected');
      setConnected(false);
      setTimeout(connect, 1500);
    };
    
    ws.onerror = (e) => {
      console.error('[TV] WebSocket error:', e);
      setConnected(false);
    };
    
    ws.onmessage = (e) => {
      try {
        const msg = JSON.parse(e.data);
        handleMessage(msg);
      } catch (err) {
        console.error('[TV] Parse error:', err);
      }
    };
  }
  
  function setConnected(connected) {
    const status = $('connStatus');
    if (status) {
      status.classList.toggle('connected', connected);
      status.querySelector('.status-text').textContent = connected ? 'Connecté' : 'Déconnecté';
    }
  }
  
  // ============ MESSAGE HANDLING ============
  function handleMessage(msg) {
    console.log('[TV] Message:', msg.type);
    
    switch (msg.type) {
      case 'PUBLIC_STATE':
        handlePublicState(msg.data);
        break;
        
      case 'NARRATOR_LINE':
        appendNarrator(msg.line);
        break;
        
      case 'VOTE_STATUS':
        updateVoteProgress(msg);
        break;
        
      case 'VOTE_RESULT':
        showExecution(msg);
        break;
        
      case 'GAME_OVER':
        state.winner = msg.winner;
        state.winner_fr = msg.winner_fr;
        showGameOver();
        break;
        
      case 'RESET':
        location.reload();
        break;
    }
  }
  
  function handlePublicState(data) {
    const oldPhase = state.phase;
    const oldAliveIds = state.alive.map(p => p.id);
    
    // Update state
    state.phase = data.phase;
    state.night_count = data.night_count || 0;
    state.day_count = data.day_count || 0;
    state.alive = data.alive || [];
    state.dead = data.dead || [];
    state.started = data.started;
    state.winner = data.winner;
    state.timers = data.timers;
    
    // Detect new deaths
    const newAliveIds = state.alive.map(p => p.id);
    const justDied = oldAliveIds.filter(id => !newAliveIds.includes(id));
    
    if (justDied.length > 0 && oldPhase !== 'LOBBY') {
      // Queue deaths for announcement
      const newDeaths = state.dead.filter(p => justDied.includes(p.id));
      if (newDeaths.length > 0) {
        deathQueue = newDeaths;
        deathIndex = 0;
      }
    }
    
    previousAliveIds = newAliveIds;
    
    // Update UI based on phase
    updateUI(oldPhase !== state.phase);
  }
  
  // ============ UI UPDATE ============
  function updateUI(phaseChanged) {
    // Always update graveyard and timer
    updateGraveyard();
    updateTimer();
    
    // Phase-specific updates
    if (state.phase === 'LOBBY') {
      if (phaseChanged) showScreen('screenLobby');
      updateLobby();
    } else if (state.phase === 'NIGHT') {
      if (phaseChanged) {
        showScreen('screenNight');
        fx?.setMode('night');
      }
      updateNight();
    } else if (state.phase === 'DAY') {
      if (phaseChanged) {
        // Show dawn with death reveals first
        if (deathQueue.length > 0) {
          showDawnSequence();
        } else {
          showScreen('screenDawn');
          $('deathTheater').style.display = 'none';
          $('noDeath').style.display = 'block';
          setTimeout(() => showScreen('screenDay'), 3000);
        }
        fx?.setMode('day');
      }
      updateDay();
    } else if (state.phase === 'VOTE') {
      if (phaseChanged) {
        showScreen('screenVote');
        buildVoteArena();
      }
      updateVote();
    } else if (state.phase === 'GAME_OVER') {
      if (phaseChanged) showGameOver();
    }
    
    lastPhase = state.phase;
  }
  
  function updateTimer() {
    const timers = {
      'nightTimer': state.timers?.seconds_left,
      'dayTimer': state.timers?.seconds_left,
      'voteTimer': state.timers?.seconds_left
    };
    
    Object.entries(timers).forEach(([id, value]) => {
      const el = $(id);
      if (el) {
        el.textContent = value != null ? `${value}s` : '--';
        el.parentElement?.classList.toggle('urgent', value != null && value <= 5);
      }
    });
  }
  
  // ============ LOBBY ============
  function updateLobby() {
    // Player count
    const count = $('playerCount');
    if (count) count.textContent = state.alive.length;
    
    // Start button
    const startBtn = $('startBtn');
    if (startBtn) {
      startBtn.disabled = state.alive.length < 5;
    }
    
    // Players in circle
    const ring = $('playersRing');
    if (ring) {
      const players = state.alive;
      const n = players.length;
      const radius = 110;
      
      ring.innerHTML = players.map((p, i) => {
        const angle = (i / n) * 2 * Math.PI - Math.PI / 2;
        const x = 140 + radius * Math.cos(angle);
        const y = 140 + radius * Math.sin(angle);
        
        return `
          <div class="player-token" style="left:${x}px;top:${y}px;">
            <div class="avatar">${(p.name || '?')[0].toUpperCase()}</div>
            <div class="name">${escapeHtml(p.name)}</div>
          </div>
        `;
      }).join('');
    }
    
    // Join URL
    const joinUrl = $('joinUrl');
    if (joinUrl) {
      const playerUrl = `${window.location.protocol}//${host}${portPart}/player/`;
      joinUrl.textContent = playerUrl;
    }
  }
  
  // ============ NIGHT ============
  function updateNight() {
    // Night number
    const nightNum = $('nightNumber');
    if (nightNum) nightNum.textContent = state.night_count;
    
    // Sleeping players
    const village = $('sleepingVillage');
    if (village) {
      village.innerHTML = state.alive.map(p => `
        <div class="sleeping-player">
          <div class="avatar">
            ${(p.name || '?')[0].toUpperCase()}
            <span class="zzz">💤</span>
          </div>
          <div class="name">${escapeHtml(p.name)}</div>
        </div>
      `).join('');
    }
  }
  
  // ============ DAWN - DEATH SEQUENCE ============
  function showDawnSequence() {
    showScreen('screenDawn');
    
    const theater = $('deathTheater');
    const noDeath = $('noDeath');
    const deathsRow = $('deathsRow');
    
    if (deathQueue.length === 0) {
      if (theater) theater.style.display = 'none';
      if (noDeath) noDeath.style.display = 'block';
      setTimeout(() => showScreen('screenDay'), 3000);
      return;
    }
    
    if (theater) theater.style.display = 'block';
    if (noDeath) noDeath.style.display = 'none';
    
    // Build all death cards and show them one by one with animation
    if (deathsRow) {
      deathsRow.innerHTML = '';
      
      deathQueue.forEach((victim, index) => {
        // Determine if this is a lover death (broken heart)
        const isLover = victim.death_cause === 'heartbreak' || victim.cause === 'heartbreak';
        const cause = isLover ? '💔 mort de chagrin' : getCauseText(victim);
        
        const cardHtml = `
          <div class="death-card ${isLover ? 'lover' : ''}" style="opacity:0;transform:scale(0.5);">
            <div class="card-glow"></div>
            <div class="card-img">
              <img src="${getRoleImage(victim.role)}" alt="${victim.role}">
            </div>
            <div class="death-info">
              <div class="victim-name">${escapeHtml(victim.name)}</div>
              <div class="victim-role">${getRoleName(victim.role)}</div>
              <div class="death-cause">${cause}</div>
            </div>
          </div>
        `;
        
        deathsRow.insertAdjacentHTML('beforeend', cardHtml);
        
        // Animate this card after a delay
        setTimeout(() => {
          const card = deathsRow.children[index];
          if (card) {
            card.style.transition = 'all 0.8s ease-out';
            card.style.opacity = '1';
            card.style.transform = 'scale(1)';
            fx?.burst({ kind: 'ember', count: 15 });
          }
        }, 500 + index * 1200); // Stagger by 1.2s each
      });
    }
    
    // Move to day after all deaths shown
    const totalDuration = 500 + deathQueue.length * 1200 + 2500;
    setTimeout(() => {
      deathQueue = [];
      deathIndex = 0;
      showScreen('screenDay');
    }, totalDuration);
  }
  
  function getCauseText(victim) {
    // Check for special causes
    if (victim.death_cause === 'wolves' || victim.cause === 'wolves') {
      return 'dévoré par les loups';
    }
    if (victim.death_cause === 'poison' || victim.cause === 'poison') {
      return 'empoisonné par la sorcière';
    }
    if (victim.death_cause === 'vote' || victim.cause === 'vote') {
      return 'exécuté par le village';
    }
    // Default
    const causes = ['a été trouvé sans vie', 'n\'a pas survécu', 'est mort cette nuit'];
    return causes[Math.floor(Math.random() * causes.length)];
  }
  
  // Keep this for backwards compat but it's not used anymore
  function showNextDeath() {
    // Deprecated - now showing all deaths at once
  }
  
  // ============ DAY ============
  function updateDay() {
    // Day number
    const dayNum = $('dayNumber');
    if (dayNum) dayNum.textContent = state.day_count;
    
    // Council members
    const council = $('councilCircle');
    if (council) {
      council.innerHTML = state.alive.map(p => `
        <div class="council-member">
          <div class="avatar">${(p.name || '?')[0].toUpperCase()}</div>
          <div class="name">${escapeHtml(p.name)}</div>
        </div>
      `).join('');
    }
  }
  
  // ============ VOTE ============
  function buildVoteArena() {
    const arena = $('voteArena');
    if (!arena) return;
    
    arena.innerHTML = state.alive.map(p => `
      <div class="vote-candidate" data-id="${p.id}">
        <div class="avatar">${(p.name || '?')[0].toUpperCase()}</div>
        <div class="name">${escapeHtml(p.name)}</div>
        <div class="votes">0</div>
        <div class="vote-bar"><div class="vote-bar-fill" style="width:0%"></div></div>
      </div>
    `).join('');
  }
  
  function updateVote() {
    // Timer is updated by updateTimer()
  }
  
  function updateVoteProgress(data) {
    // Update progress bar
    const fill = $('voteFill');
    const count = $('voteCount');
    const total = $('voteTotal');
    
    if (count) count.textContent = data.received || 0;
    if (total) total.textContent = data.total || 0;
    if (fill && data.total > 0) {
      fill.style.width = ((data.received / data.total) * 100) + '%';
    }
  }
  
  // ============ EXECUTION ============
  function showExecution(data) {
    showScreen('screenExecution');
    
    const img = $('condemnedImg');
    const name = $('condemnedName');
    const role = $('condemnedRole');
    const tally = $('voteTally');
    
    if (data.eliminated) {
      if (img) img.src = getRoleImage(data.eliminated.role);
      if (name) name.textContent = data.eliminated.name;
      if (role) role.textContent = data.eliminated.role_fr || getRoleName(data.eliminated.role);
      
      fx?.burst({ kind: 'ember', count: 30 });
    } else {
      if (name) name.textContent = 'Personne';
      if (role) role.textContent = 'Pas d\'élimination';
    }
    
    // Show vote breakdown
    if (tally && data.tally) {
      tally.innerHTML = data.tally.map(t => `
        <div class="tally-item">
          <span>${escapeHtml(t.name)}</span>: <span class="count">${t.votes}</span>
        </div>
      `).join('');
    }
  }
  
  // ============ GAME OVER ============
  function showGameOver() {
    showScreen('screenGameOver');
    
    const banner = $('victoryBanner');
    const icon = $('victoryIcon');
    const title = $('victoryTitle');
    const team = $('victoryTeam');
    const roles = $('allRoles');
    
    if (state.winner === 'werewolves') {
      if (banner) banner.classList.add('wolves');
      if (icon) icon.textContent = '🐺';
      if (title) title.textContent = 'Les Loups Triomphent!';
      if (team) team.textContent = 'Le village a été dévoré...';
    } else if (state.winner === 'villagers') {
      if (banner) banner.classList.remove('wolves');
      if (icon) icon.textContent = '🏆';
      if (title) title.textContent = 'Le Village Triomphe!';
      if (team) team.textContent = 'Tous les loups ont été éliminés!';
    } else {
      if (banner) banner.classList.remove('wolves');
      if (icon) icon.textContent = '💀';
      if (title) title.textContent = 'Personne ne Survit';
      if (team) team.textContent = 'Tout le monde est mort...';
    }
    
    // Reveal all roles - show actual role images with staggered animation
    if (roles) {
      const allPlayers = [...state.alive, ...state.dead];
      roles.innerHTML = allPlayers.map(p => `
        <div class="role-card ${p.role === 'werewolf' ? 'wolf' : ''}" data-player="${p.id}">
          <div class="card-img">
            <img src="${getRoleImage(p.role)}" alt="${p.role}">
          </div>
          <div class="name">${escapeHtml(p.name)}</div>
          <div class="role">${getRoleName(p.role)}</div>
        </div>
      `).join('');
      
      // Animate cards revealing one by one
      const cards = roles.querySelectorAll('.role-card');
      cards.forEach((card, index) => {
        setTimeout(() => {
          card.classList.add('revealed');
          fx?.burst({ kind: 'spark', count: 6 });
        }, 200 + index * 300);
      });
    }
    
    fx?.burst({ kind: 'magic', count: 50 });
  }
  
  // ============ GRAVEYARD ============
  function updateGraveyard() {
    const tombs = $('graveyardTombs');
    const count = $('deadCount');
    
    if (count) count.textContent = state.dead.length;
    
    if (tombs) {
      if (state.dead.length === 0) {
        tombs.innerHTML = '<div style="color:var(--text-dim);font-size:13px;padding:8px;">Aucune âme... pour l\'instant</div>';
      } else {
        tombs.innerHTML = state.dead.map(p => `
          <div class="tomb ${p.role === 'werewolf' ? 'wolf' : ''}">
            <div class="tomb-card">
              <img src="${getRoleImage(p.role)}" alt="${p.role}">
            </div>
            <div class="info">
              <div class="name">${escapeHtml(p.name)}</div>
              <div class="role">${getRoleName(p.role)}</div>
            </div>
          </div>
        `).join('');
      }
    }
  }
  
  // ============ NARRATOR ============
  function appendNarrator(line) {
    const log = $('narratorLog');
    if (log) {
      log.textContent += line + '\n';
      log.scrollTop = log.scrollHeight;
    }
  }
  
  // Narrator panel toggle
  const narratorBtn = $('narratorBtn');
  const narratorPanel = $('narratorPanel');
  const closeNarrator = $('closeNarrator');
  
  if (narratorBtn) {
    narratorBtn.addEventListener('click', () => {
      narratorPanel?.classList.toggle('open');
    });
  }
  
  if (closeNarrator) {
    closeNarrator.addEventListener('click', () => {
      narratorPanel?.classList.remove('open');
    });
  }
  
  // ============ CONFIGURATION ============
  const configToggle = $('configToggle');
  const configPanel = $('configPanel');
  
  if (configToggle && configPanel) {
    configToggle.addEventListener('click', () => {
      configPanel.classList.toggle('open');
    });
  }
  
  // Role card selection
  const rolesGrid = $('rolesCardsGrid');
  if (rolesGrid) {
    rolesGrid.addEventListener('click', (e) => {
      const card = e.target.closest('.role-config-card');
      if (!card || card.classList.contains('disabled')) return;
      
      const checkbox = card.querySelector('input[type="checkbox"]');
      if (checkbox) {
        checkbox.checked = !checkbox.checked;
        card.classList.toggle('active', checkbox.checked);
        fx?.burst({ kind: 'spark', count: 6 });
      }
    });
  }
  
  const applyConfigBtn = $('applyConfigBtn');
  if (applyConfigBtn) {
    applyConfigBtn.addEventListener('click', async () => {
      // Read config values in minutes only
      const nightMin = parseInt($('cfgNightMin')?.value) || 1;
      const dayMin = parseInt($('cfgDayMin')?.value) || 1;
      const voteMin = parseInt($('cfgVoteMin')?.value) || 1;
      const resultMin = parseInt($('cfgResultMin')?.value) || 0;
      
      config.nightAction = Math.max(10, nightMin * 60);
      config.dayDiscuss = Math.max(10, dayMin * 60);
      config.voteTime = Math.max(10, voteMin * 60);
      config.resultTime = Math.max(3, resultMin * 60 || 5);
      
      // Read role selections
      config.roles = {
        seer: $('cfgRoleSeer')?.checked ?? true,
        witch: $('cfgRoleWitch')?.checked ?? true,
        cupid: $('cfgRoleCupid')?.checked ?? true,
        hunter: $('cfgRoleHunter')?.checked ?? false
      };
      
      console.log('[TV] Config applied:', config);
      
      // Send to server
      try {
        const res = await fetch(API_URL + '/api/config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(config)
        });
        if (res.ok) {
          fx?.burst({ kind: 'spark', count: 20 });
          applyConfigBtn.textContent = '✓ Appliqué!';
          setTimeout(() => {
            applyConfigBtn.textContent = '✓ Appliquer';
          }, 2000);
        }
      } catch (e) {
        console.warn('[TV] Config update failed:', e);
      }
      
      // Close panel
      configPanel?.classList.remove('open');
    });
  }
  
  // ============ BUTTONS ============
  const startBtn = $('startBtn');
  if (startBtn) {
    startBtn.addEventListener('click', async () => {
      startBtn.disabled = true;
      startBtn.innerHTML = '<span class="btn-icon">⏳</span><span>Configuration...</span>';
      
      // First, send the config
      try {
        // Read timer values (only minutes now)
        const nightMin = parseInt($('cfgNightMin')?.value) || 1;
        const dayMin = parseInt($('cfgDayMin')?.value) || 1;
        const voteMin = parseInt($('cfgVoteMin')?.value) || 1;
        const resultMin = parseInt($('cfgResultMin')?.value) || 0;
        
        config.nightAction = Math.max(10, nightMin * 60);
        config.dayDiscuss = Math.max(10, dayMin * 60);
        config.voteTime = Math.max(10, voteMin * 60);
        config.resultTime = Math.max(3, resultMin * 60 || 5);
        
        // Read role selections
        config.roles = {
          seer: $('cfgRoleSeer')?.checked ?? true,
          witch: $('cfgRoleWitch')?.checked ?? true,
          cupid: $('cfgRoleCupid')?.checked ?? true,
          hunter: $('cfgRoleHunter')?.checked ?? false
        };
        
        console.log('[TV] Sending config before start:', config);
        
        await fetch(API_URL + '/api/config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(config)
        });
      } catch (e) {
        console.warn('[TV] Config send failed:', e);
      }
      
      // Then start the game
      startBtn.innerHTML = '<span class="btn-icon">⏳</span><span>Lancement...</span>';
      
      try {
        const res = await fetch(API_URL + '/api/start', { method: 'POST' });
        const data = await res.json();
        
        if (!data.ok) {
          alert('Erreur: ' + (data.error || 'Impossible de démarrer'));
          startBtn.disabled = false;
          startBtn.innerHTML = '<span class="btn-icon">⚔️</span><span>Que la chasse commence!</span>';
        }
      } catch (e) {
        console.error('[TV] Start error:', e);
        startBtn.disabled = false;
        startBtn.innerHTML = '<span class="btn-icon">⚔️</span><span>Que la chasse commence!</span>';
      }
    });
  }
  
  const resetBtn = $('resetBtn');
  if (resetBtn) {
    resetBtn.addEventListener('click', async () => {
      if (!confirm('Recommencer une nouvelle partie?')) return;
      
      try {
        await fetch(API_URL + '/api/reset', { method: 'POST' });
      } catch (e) {
        console.error('[TV] Reset error:', e);
      }
    });
  }
  
  // ============ AMBIENT EFFECTS ============
  function createAmbientParticles() {
    const container = $('ambientParticles');
    if (!container) return;
    
    // Create floating particles
    for (let i = 0; i < 20; i++) {
      const particle = document.createElement('div');
      particle.style.cssText = `
        position: absolute;
        width: ${2 + Math.random() * 4}px;
        height: ${2 + Math.random() * 4}px;
        background: rgba(255, 255, 255, ${0.1 + Math.random() * 0.2});
        border-radius: 50%;
        left: ${Math.random() * 100}%;
        top: ${Math.random() * 100}%;
        animation: float ${10 + Math.random() * 20}s linear infinite;
        animation-delay: ${-Math.random() * 20}s;
      `;
      container.appendChild(particle);
    }
  }
  
  // Add float animation
  const style = document.createElement('style');
  style.textContent = `
    @keyframes float {
      0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { transform: translateY(-100px) rotate(720deg); opacity: 0; }
    }
  `;
  document.head.appendChild(style);
  
  // ============ INITIALIZE ============
  createAmbientParticles();
  connect();
  
  console.log('[TV] === INITIALIZATION COMPLETE ===');
}

====================================================================================================
PATH: web\static\tv.css
-----------------------
/* TV screen layout (wide) */
.tv-wrap{ width:min(1200px, 96vw); margin: 18px auto 22px; }
.tv-header{
  display:flex; align-items:flex-start; justify-content:space-between; gap:14px;
}
.tv-header .left{ display:flex; flex-direction:column; gap:8px; }
.tv-header h1{ margin:0; font-size: 26px; letter-spacing:.02em; }
.tv-pills{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
.tv-pills .pill{ padding: 8px 12px; border-radius: 999px; }
.tv-actions{ display:flex; gap:10px; align-items:center; }
.tv-actions .btn{ width:auto; padding: 10px 14px; }
.tv-grid{
  margin-top: 14px;
  display:grid;
  grid-template-columns: 1.1fr .9fr;
  gap: 14px;
}
@media (max-width: 980px){
  .tv-grid{ grid-template-columns: 1fr; }
}
.panel-title{ margin: 0 0 10px; font-size: 14px; letter-spacing:.06em; text-transform: uppercase; color: rgba(247,242,230,.72); }
.list{ display:flex; flex-direction:column; gap:8px; }
.listItem{
  display:flex; align-items:center; justify-content:space-between; gap:10px;
  padding: 10px 12px;
  border-radius: 16px;
  background: rgba(0,0,0,.18);
  border: 1px solid rgba(255,255,255,.12);
}
.listItem .name{ font-weight: 700; }
.listItem .meta{ font-size: 12px; color: rgba(247,242,230,.72); }
pre#log{
  margin:0;
  max-height: 320px;
  overflow:auto;
  padding: 10px 12px;
  border-radius: 16px;
  background: rgba(0,0,0,.2);
  border: 1px solid rgba(255,255,255,.10);
  white-space: pre-wrap;
}
.voteBox{ display:flex; flex-direction:column; gap:10px; }
.voteRow{ display:flex; justify-content:space-between; gap:12px; }
.voteRow .bar{
  flex:1;
  height: 10px;
  border-radius: 999px;
  background: rgba(255,255,255,.10);
  overflow:hidden;
}
.voteRow .bar > div{
  height: 100%;
  width: 0%;
  background: rgba(214,177,90,.55);
}
.voteRow .label{ width: 160px; font-weight: 650; }
.voteRow .count{ width: 42px; text-align:right; font-variant-numeric: tabular-nums; }
.footerRow{
  margin-top: 14px;
  display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;
}
.mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace; }

====================================================================================================
PATH: web\static\tv.js
----------------------
(() => {
  const $ = (id) => document.getElementById(id);

  const root = document.querySelector('.app');
  if (window.LG) LG.applyThemeFromQuery(root);

  const { qs, host, port, apiOrigin: API_ORIGIN, wsOrigin: WS_ORIGIN } = LG.parseBackendFromQuery();
  $('backendOrigin').textContent = API_ORIGIN;

  const fx = window.LGFX?.init($('fxCanvas'), { mode: 'night' });
  const sfx = window.LGSFX?.fromQuery?.() || null;

  const logEl = $('log');
  function appendLog(line){
    logEl.textContent += line + '\n';
    logEl.scrollTop = logEl.scrollHeight;
  }

  // Buttons
  const startBtn = $('startBtn');
  const resetBtn = $('resetBtn');
  const copyJoinBtn = $('copyJoinBtn');

  startBtn?.addEventListener('click', async () => {
    try{
      sfx?.confirm?.();
      const r = await fetch(`${API_ORIGIN}/api/start`, { method:'POST' });
      const j = await r.json();
      if (!j.ok) throw new Error(j.error || 'start failed');
      fx?.burst({ kind:'magic', count: 26 });
    }catch(e){ alert(String(e)); }
  });
  resetBtn?.addEventListener('click', async () => {
    if (!confirm('Réinitialiser la partie ?')) return;
    try{
      sfx?.warn?.();
      const r = await fetch(`${API_ORIGIN}/api/reset`, { method:'POST' });
      const j = await r.json();
      if (!j.ok) throw new Error(j.error || 'reset failed');
      logEl.textContent = '';
      fx?.burst({ kind:'ember', count: 22 });
    }catch(e){ alert(String(e)); }
  });

  copyJoinBtn?.addEventListener('click', async () => {
    // Share a working URL for players (same backend host/port)
    const joinUrl = `${location.protocol}//${host}:${port}/player/?autojoin=1`;
    try{
      sfx?.click?.();
      if (navigator.clipboard?.writeText) {
        await navigator.clipboard.writeText(joinUrl);
        appendLog(`🔗 Lien joueur copié : ${joinUrl}`);
      } else {
        prompt('Copiez le lien joueur :', joinUrl);
      }
      fx?.burst({ kind: 'spark', count: 14 });
    } catch {
      prompt('Copiez le lien joueur :', joinUrl);
    }
  });

  let currentPhase = '—';

  function setNightMode(isNight){
    root.classList.toggle('is-night', isNight);
    fx?.setMode(isNight ? 'night' : 'day');
  }

  function renderPlayers(listEl, players, { revealed } = { revealed: false }){
    listEl.innerHTML = '';
    if (!players.length){
      listEl.innerHTML = '<div class="muted">—</div>';
      return;
    }
    for (const p of players){
      const item = document.createElement('div');
      item.className = 'listItem';
      const img = document.createElement('img');
      img.className = 'miniRole';
      img.alt = revealed ? 'role' : 'verso';
      if (revealed && p.role){
        const files = LG.cardForRole(p.role);
        LG.setImgWithFallback(img, files.primary, files.fallback);
      } else {
        LG.setImgWithFallback(img, LG.VERSO.primary, LG.VERSO.fallback);
      }

      const left = document.createElement('div');
      left.style.display = 'flex';
      left.style.alignItems = 'center';
      left.style.gap = '10px';
      left.appendChild(img);

      const txt = document.createElement('div');
      txt.innerHTML = `<div class="name">${LG.escapeHtml(p.name)}</div>` +
        `<div class="meta mono">${LG.escapeHtml(p.id)}</div>`;
      left.appendChild(txt);

      const right = document.createElement('div');
      if (revealed) {
        const roleLabel = p.role_fr || LG.roleLabel(p.role);
        right.innerHTML = `<div class="meta">${LG.escapeHtml(roleLabel || '—')}</div>`;
      } else {
        right.innerHTML = `<div class="meta">Vivant</div>`;
      }

      item.appendChild(left);
      item.appendChild(right);
      listEl.appendChild(item);
    }
  }

  function renderVotes(voteBoxEl, alive, dead, state){
    voteBoxEl.innerHTML = '';

    const vr = window.__voteResult || null;

    if (state.phase !== 'VOTE' && state.phase !== 'RESULT'){
      voteBoxEl.innerHTML = '<div class="muted">Pas de vote pour cette phase.</div>';
      return;
    }

    if (!vr) {
      voteBoxEl.innerHTML = '<div class="muted">En attente des résultats de vote…</div>';
      return;
    }

    // Build bars from tally
    // Backend sends `tally` as an array: [{id,name,votes}, ...]
    // (Keep compatibility if it ever becomes an object map.)
    const rows = Array.isArray(vr.tally)
      ? vr.tally.map(r => ({ id: r.id, name: r.name, count: Number(r.votes ?? r.count) || 0 }))
      : Object.entries(vr.tally || {}).map(([id, count]) => ({ id, name: null, count: Number(count) || 0 }));

    rows.sort((a,b) => b.count - a.count);

    const total = rows.reduce((s,r) => s + r.count, 0) || 1;
    const nameById = new Map([...(alive||[]), ...(dead||[])].map(p => [p.id, p.name]));

    const box = document.createElement('div');
    box.style.display = 'grid';
    box.style.gap = '10px';

    for (const r of rows) {
      const pct = Math.round((r.count / total) * 100);
      const name = r.name || nameById.get(r.id) || r.id;
      const row = document.createElement('div');
      row.innerHTML = `
        <div class="kv">
          <div><b>${LG.escapeHtml(name)}</b> <span class="muted mono">(${LG.escapeHtml(r.id)})</span></div>
          <div class="muted"><b>${r.count}</b> vote(s) • ${pct}%</div>
        </div>
        <div class="bar"><div class="fill" style="width:${pct}%;"></div></div>
      `;
      box.appendChild(row);
    }

    voteBoxEl.appendChild(box);

    // Eliminated card
    if (vr.eliminated) {
      const elim = vr.eliminated;
      const roleLabel = elim.role_fr || LG.roleLabel(elim.role);
      const files = LG.cardForRole(elim.role);
      const card = document.createElement('div');
      card.className = 'resultCard';
      card.innerHTML = `
        <div class="resultTop">
          <div>
            <div class="muted">Éliminé</div>
            <div style="font-size:18px;font-weight:950;">${LG.escapeHtml(elim.name)}</div>
            <div class="muted">${LG.escapeHtml(roleLabel)}</div>
          </div>
          <img class="miniRole" id="elimImg" alt="role" />
        </div>
      `;
      voteBoxEl.appendChild(card);
      setTimeout(() => {
        const img = document.getElementById('elimImg');
        if (img) LG.setImgWithFallback(img, files.primary, files.fallback);
      }, 0);
    }

    if (vr.ties && vr.ties.length) {
      const t = document.createElement('div');
      t.className = 'muted';
      t.textContent = `Égalité: ${vr.ties.length} joueur(s) — nouveau vote ou règle maison.`;
      voteBoxEl.appendChild(t);
    }
  }

  function applyState(state){
    if (!state) return;
    window.__lastPublicState = state;
    const phase = state.phase || '—';
    $('phase').textContent = phase;
    $('aliveCount').textContent = String((state.alive || []).length);
    $('deadCount').textContent = String((state.dead || []).length);

    const secs = state.timers?.seconds_left;
    $('timer').textContent = (secs === null || secs === undefined) ? '—' : `${secs}s`;

    if (phase !== currentPhase){
      currentPhase = phase;
      fx?.burst({ kind: phase === 'NIGHT' ? 'magic' : 'ember', count: 20 });
    }
    setNightMode(phase === 'NIGHT');

    renderPlayers($('aliveList'), state.alive || [], { revealed: false });
    renderPlayers($('deadList'), state.dead || [], { revealed: true });
    renderVotes($('voteBox'), state.alive || [], state.dead || [], state);

    if (phase === 'GAME_OVER' && state.winner){
      fx?.burst({ kind:'magic', count: 40 });
      const w = state.winner === 'villagers' ? 'Les Villageois'
        : state.winner === 'werewolves' ? 'Les Loups-Garous'
        : state.winner === 'nobody' ? 'Personne'
        : state.winner;
      appendLog(`🏁 Victoire : ${w}`);
    }
  }

  // WebSocket
  let ws;
  function connect(){
    const url = `${WS_ORIGIN}/ws?client=tv`;
    ws = new WebSocket(url);
    $('ws').textContent = 'connexion…';

    ws.onopen = () => {
      $('ws').textContent = 'connecté';
      fx?.burst({ kind:'magic', count: 16 });
    };
    ws.onclose = () => {
      $('ws').textContent = 'déconnecté';
      setTimeout(connect, 700);
    };
    ws.onerror = () => { $('ws').textContent = 'erreur'; };

    ws.onmessage = (ev) => {
      let msg;
      try{ msg = JSON.parse(ev.data); }catch{ return; }
      if (msg.type === 'PUBLIC_STATE'){
        applyState(msg.data);
      } else if (msg.type === 'VOTE_RESULT'){
        window.__voteResult = msg;
        fx?.burst({ kind:'spark', count: 20 });
        // refresh immediately
        const last = window.__lastPublicState;
        if (last) renderVotes($('voteBox'), last.alive || [], last.dead || [], last);
      } else if (msg.type === 'NARRATOR_LINE'){
        window.__narratorLines = window.__narratorLines || [];
        window.__narratorLines.push(msg.line);
        window.__narratorLines = window.__narratorLines.slice(-200);
        appendLog(msg.line);
      } else if (msg.type === 'RESET'){
        window.__narratorLines = [];
        window.__voteResult = null;
        logEl.textContent = '';
        $('voteBox').innerHTML = '<div class="muted">Aucun vote pour l’instant.</div>';
      }
    };
  }

  connect();
})();

====================================================================================================
PATH: web\tv\index.html
-----------------------
<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>🐺 Loup-Garou - Maître du Jeu</title>
  <link rel="stylesheet" href="/static/tv-game.css">
</head>

<body>
  <div id="app" class="tv-app">
    <!-- Animated background canvas -->
    <canvas id="fxCanvas"></canvas>
    
    <!-- Ambient particles -->
    <div class="ambient-particles" id="ambientParticles"></div>

    <!-- ==================== SCREEN: LOBBY ==================== -->
    <div id="screenLobby" class="screen active">
      <div class="lobby-container">
        <!-- Title with medieval flair -->
        <div class="lobby-header">
          <div class="torch left">🔥</div>
          <div class="title-crest">
            <div class="crest-icon">🐺</div>
            <h1 class="game-title">Loup-Garou</h1>
            <p class="game-subtitle">de Thiercelieux</p>
          </div>
          <div class="torch right">🔥</div>
        </div>

        <!-- Configuration Panel -->
        <div class="config-panel" id="configPanel">
          <div class="config-header" id="configToggle">
            <span>⚙️ Configuration de la Partie</span>
            <span class="toggle-icon">▼</span>
          </div>
          <div class="config-body" id="configBody">
            <!-- Timers in Minutes only -->
            <div class="config-section">
              <h3>⏱️ Durées (minutes)</h3>
              <div class="config-grid">
                <div class="config-item">
                  <label>Actions nuit</label>
                  <input type="number" id="cfgNightMin" value="1" min="1" max="10">
                </div>
                <div class="config-item">
                  <label>Discussion</label>
                  <input type="number" id="cfgDayMin" value="1" min="1" max="10">
                </div>
                <div class="config-item">
                  <label>Vote</label>
                  <input type="number" id="cfgVoteMin" value="1" min="1" max="10">
                </div>
                <div class="config-item">
                  <label>Résultats</label>
                  <input type="number" id="cfgResultMin" value="0" min="0" max="2">
                </div>
              </div>
            </div>
            
            <!-- Roles as Cards -->
            <div class="config-section">
              <h3>🎭 Rôles à inclure</h3>
              <div class="roles-cards-grid" id="rolesCardsGrid">
                <div class="role-config-card active" data-role="seer">
                  <input type="checkbox" id="cfgRoleSeer" checked>
                  <div class="card-image">
                    <img src="/static/cards/voyante.jpg" alt="Voyante">
                  </div>
                  <div class="card-name">Voyante</div>
                </div>
                <div class="role-config-card active" data-role="witch">
                  <input type="checkbox" id="cfgRoleWitch" checked>
                  <div class="card-image">
                    <img src="/static/cards/sorcerer.jpg" alt="Sorcière">
                  </div>
                  <div class="card-name">Sorcière</div>
                </div>
                <div class="role-config-card active" data-role="cupid">
                  <input type="checkbox" id="cfgRoleCupid" checked>
                  <div class="card-image">
                    <img src="/static/cards/cupidon.jpg" alt="Cupidon">
                  </div>
                  <div class="card-name">Cupidon</div>
                </div>
                <div class="role-config-card disabled" data-role="hunter">
                  <input type="checkbox" id="cfgRoleHunter" disabled>
                  <div class="card-image">
                    <img src="/static/cards/hunter.jpg" alt="Chasseur">
                  </div>
                  <div class="card-name">Chasseur</div>
                  <span class="card-badge">Bientôt</span>
                </div>
              </div>
            </div>

            <button id="applyConfigBtn" class="btn-config">✓ Appliquer</button>
          </div>
        </div>

        <!-- Players Circle -->
        <div class="village-circle">
          <div class="village-center">
            <div class="player-count">
              <span id="playerCount">0</span>
              <small>villageois</small>
            </div>
          </div>
          <div class="players-ring" id="playersRing">
            <!-- Players appear here in a circle -->
          </div>
        </div>

        <!-- Join Info -->
        <div class="join-banner">
          <div class="join-qr">📱</div>
          <div class="join-info">
            <div class="join-label">Rejoindre la partie</div>
            <code id="joinUrl">http://...</code>
          </div>
        </div>

        <!-- Start Button -->
        <button id="startBtn" class="btn-start" disabled>
          <span class="btn-icon">⚔️</span>
          <span>Que la chasse commence!</span>
        </button>
        <p class="min-players-hint">Minimum 5 joueurs requis</p>
      </div>
    </div>

    <!-- ==================== SCREEN: NIGHT ==================== -->
    <div id="screenNight" class="screen">
      <div class="night-container">
        <div class="moon-phase">
          <div class="moon">🌙</div>
          <div class="stars">✨</div>
        </div>
        
        <div class="night-info">
          <h2 class="night-title">Nuit <span id="nightNumber">1</span></h2>
          <p class="night-subtitle" id="nightSubtitle">Le village s'endort...</p>
        </div>

        <div class="night-timer">
          <div class="timer-circle">
            <span id="nightTimer">--</span>
          </div>
        </div>

        <!-- Current action indicator -->
        <div class="current-action" id="currentAction">
          <div class="action-icon" id="actionIcon">🐺</div>
          <div class="action-text" id="actionText">Les loups chassent...</div>
        </div>

        <!-- Sleeping villagers -->
        <div class="sleeping-village" id="sleepingVillage">
          <!-- Players shown sleeping -->
        </div>
      </div>
    </div>

    <!-- ==================== SCREEN: DAWN (Death Reveal) ==================== -->
    <div id="screenDawn" class="screen">
      <div class="dawn-container">
        <div class="sun-rising">
          <div class="sun">☀️</div>
        </div>
        
        <h2 class="dawn-title">L'aube se lève...</h2>
        
        <!-- Deaths row - shows all deaths side by side -->
        <div class="death-theater" id="deathTheater">
          <div class="deaths-row" id="deathsRow">
            <!-- Death cards will be inserted here -->
          </div>
        </div>

        <!-- No death message -->
        <div class="no-death" id="noDeath" style="display:none;">
          <div class="miracle-icon">✨</div>
          <p>Le village se réveille... personne n'est mort cette nuit!</p>
        </div>
      </div>
    </div>

    <!-- ==================== SCREEN: DAY ==================== -->
    <div id="screenDay" class="screen">
      <div class="day-container">
        <div class="day-header">
          <div class="sun-icon">☀️</div>
          <h2>Jour <span id="dayNumber">1</span></h2>
          <p class="day-subtitle">Le village délibère</p>
        </div>

        <div class="day-timer">
          <div class="hourglass">⏳</div>
          <span id="dayTimer">--</span>
        </div>

        <!-- Living players arranged in a circle -->
        <div class="council-circle" id="councilCircle">
          <!-- Players in deliberation -->
        </div>

        <div class="discussion-hint">
          <p>💬 Discutez et trouvez les loups!</p>
        </div>
      </div>
    </div>

    <!-- ==================== SCREEN: VOTE ==================== -->
    <div id="screenVote" class="screen">
      <div class="vote-container">
        <div class="vote-header">
          <div class="scales">⚖️</div>
          <h2>Le Tribunal</h2>
          <p>Le village doit choisir</p>
        </div>

        <div class="vote-timer">
          <span id="voteTimer">--</span>
        </div>

        <div class="vote-progress">
          <div class="progress-bar">
            <div class="progress-fill" id="voteFill"></div>
          </div>
          <div class="progress-text">
            <span id="voteCount">0</span> / <span id="voteTotal">0</span> votes
          </div>
        </div>

        <!-- Vote arena - shows who is being voted -->
        <div class="vote-arena" id="voteArena">
          <!-- Candidates with vote counts -->
        </div>
      </div>
    </div>

    <!-- ==================== SCREEN: EXECUTION ==================== -->
    <div id="screenExecution" class="screen">
      <div class="execution-container">
        <h2 class="verdict-title">Le Verdict</h2>
        
        <div class="execution-stage">
          <div class="gallows">
            <div class="noose">⛓️</div>
          </div>
          
          <div class="condemned-card" id="condemnedCard">
            <img id="condemnedImg" src="/static/cards/verso.jpg" alt="">
            <div class="condemned-info">
              <div class="condemned-name" id="condemnedName">???</div>
              <div class="condemned-role" id="condemnedRole">???</div>
            </div>
          </div>
        </div>

        <div class="vote-tally" id="voteTally">
          <!-- Vote breakdown -->
        </div>
      </div>
    </div>

    <!-- ==================== SCREEN: GAME OVER ==================== -->
    <div id="screenGameOver" class="screen">
      <div class="gameover-container">
        <div class="victory-banner" id="victoryBanner">
          <div class="victory-icon" id="victoryIcon">🏆</div>
          <h1 class="victory-title" id="victoryTitle">Victoire!</h1>
          <p class="victory-team" id="victoryTeam">Les Villageois</p>
        </div>

        <div class="final-reveal">
          <h3>Révélation finale</h3>
          <div class="all-roles" id="allRoles">
            <!-- All players with their roles revealed -->
          </div>
        </div>

        <button id="resetBtn" class="btn-reset">
          <span>🔄</span> Nouvelle Partie
        </button>
      </div>
    </div>

    <!-- ==================== GRAVEYARD (always visible) ==================== -->
    <div class="graveyard" id="graveyard">
      <div class="graveyard-header">
        <span class="grave-icon">⚰️</span>
        <span>Cimetière</span>
        <span class="grave-count">(<span id="deadCount">0</span>)</span>
      </div>
      <div class="graveyard-tombs" id="graveyardTombs">
        <!-- Dead players shown here -->
      </div>
    </div>

    <!-- ==================== NARRATOR LOG ==================== -->
    <div class="narrator-btn" id="narratorBtn">📜</div>
    <div class="narrator-panel" id="narratorPanel">
      <div class="narrator-header">
        <span>📜 Chroniques du Village</span>
        <button id="closeNarrator">✕</button>
      </div>
      <div class="narrator-scroll" id="narratorLog"></div>
    </div>

    <!-- ==================== CONNECTION STATUS ==================== -->
    <div class="connection-status" id="connStatus">
      <span class="status-dot"></span>
      <span class="status-text">Connexion...</span>
    </div>
  </div>

  <script src="/static/tv-game.js"></script>
</body>

</html>

====================================================================================================
